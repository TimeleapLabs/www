title { Watermark Plugin }

My goal as the new DevRel engineer is to learn and build in public, creating
useful examples along the way. That's why my next project is to build an image
watermarking plugin.

This project is a perfect choice for a few reasons:

list {
    items = bold { Working with Files }: 
    I want to learn how to handle different data types specifically image files
    in Sia.,
    items = bold { A Useful Function }:
    Watermarking is a genuinely useful function that anyone from small
    businesses to individual creators can use. A good real use case example for
    a plugin.,
    items = "This plugin perfectly demonstrates the purpose of Timeleap's
    distributed network. You can create a powerful plugin, add it to a subnet,
    and set a fee for its usage. Other developers can then tap into the
    network's computation power to use your function for their own needs,
    turning your code into a monetized application."
}

In this article, I'll take you through my journey of building this plugin, from
my initial learning to the final implementation.

title { My Journey: A Learning Log, size = 2 }

list {
    items = bold { Understanding the Core Task }: 
    "Before writing any code, I need a clear picture of how image watermarking
    works. I'll be using Sharp.js to generate text as SVGs and then apply them
    as watermarks",
    items = bold { Schema Definition }:
    "The first piece of code I'll write is the Sia schema for the plugin. This
    is the contract that defines what the plugin does. It must accept
    the image data and the watermark text as arguments and return the
    watermarked image file. I'll share my draft schema here and explain the
    reasoning behind each data type."
}

code {
    language = sia,
    content = """
    schema Args {
        text   string8(encoding = "ascii")
        location string8(encoding = "ascii")
        image byte32
    }

    schema Fee {
        amount     uint64
        currency   string8(encoding = "ascii")
    }

    schema WatermarkImageCall {
        uuid    byte8
        plugin  string8(encoding = "ascii")
        method  string8(encoding = "ascii")
        timeout uint64
        fee     Fee
        args    Args
    }

    schema WatermarkImageResponse {
        opcode    uint8
        appId     uint64
        uuid      byte8
        error?    uint16
        ok?       bool
        watermarkedImage?  byte32
    }


    plugin swiss.timeleap.watermarker as WatermarkImage {
        method addWatermarkToImage(timeout = 5000, fee = 1, currency = "USD") Args returns {
            ok bool
            watermarkedImage byte32
        }
    }
"""
}

Similar to link { to = /blog/developer-journey/hello-world-timeleap-app,
hello-world }, we need args, fee, call, and response. These define what we
expect: the watermark text, the image, and the position where the user wants the
watermark applied. Once defined, we add the args and fee to the call. Later on,
we can extend this into the tlp CLI. By default, a plugin schema should contain
inlineCode { args, fee, call, response }. We'll return to the tlp CLI later in
the article.

title { Building the Plugin, size = 3 }

This is where the core logic goes. I'll implement the inlineCode {
addWaterMarkToImage } function, which takes the input image and text, applies
the watermark using my chosen library, and returns the result.

I used tlp CLI to install and run the Timeleap broker and worker in the
inlineCode { ./timeleap } directory of my project. Next, I need to implement the
plugin. Following the example plugins repository, I'm using Bun and workspaces
since I'll also be building the client. The Sia-generated code needs to be
usable by both the plugin and the client, so I created a shared folder with a
models directory and added a simple package.json:

code {
    language = json,
    content = """
    {
     "name": "@shared/models",
     "version": "1.0.0",
     "main": "index.ts"
    }
"""
}

I added it to the Bun workspaces in the root inlineCode { package.json }, and
placed the Sia model and the generated code inside inlineCode { models }.

I did the same setup for the plugin as well.

Now we need to decide what goes into the plugin code. The plugin needs a wallet
and an identity so it can sign the responses it provides. To set this up, we
need two steps:

First, install the SDK. I did this in the root directory with:

code {
    language = bash,
    content = """
    bun install @timeleap/client --dev
    """
}

Next, we need the worker's public key, which is located in inlineCode {
./timeleap/secrets/worker_secrets.yaml }. We also need to generate an identity
for the plugin. To handle that, I used the Timeleap SDK again. I created a utils
folder inside the plugin directory and added this:

code {
    language = typescript,
    content = """
	import { Wallet } from '@timeleap/client';

	const wallet = await Wallet.random();
	const encoded = wallet.toBase58();

	console.log('sk:', encoded.privateKey);
	console.log('pk:', encoded.publicKey);
"""
}

We also make this a script called generate:key inside the package.json. to run
the code above.

code {
    language = json,
    content = """
    "generate:key": "bun run utils/ed.ts"
"""
}

Second, we need to enable WebSocket calls to the plugin. How do we do that with
Bun? I did a quick link { to = https://bun.com/docs/api/websockets , search }
and followed their example. While looking into it, I got curious about the term
inlineCode { upgrade }. In the context of WebSockets, upgrade refers to
converting an existing HTTP connection into a WebSocket connection.

For now, we'll ignore the upgrade logic.

code {
    language = typescript,
    content = """
    Bun.serve({
        fetch(req, server) {}, // upgrade logic
        websocket: {
            message(ws, message) {}, // a message is received
            open(ws) {}, // a socket is opened
            close(ws, code, message) {}, // a socket is closed
            drain(ws) {}, // the socket is ready to receive more data
        },
    });
"""
}

On message, we need to extract the args from the request, take the image and
watermark text, and combine them using Sharp. Let's implement that:

code {
    language = typescript,
    content = """
    Bun.serve({
    fetch(req, server) { }, // upgrade logic
    websocket: {
        async message(ws, message: Buffer) {
            if (!(await worker.verify(message))) {
                console.error('Invalid signature')

                return
            }

            const { uuid, plugin, method, args } = decodeWatermarkImageCall(
                new Sia(message).skip(9),
            )
        }, // a message is received
        open() {
            console.info('Hey, a new connection just happend')
        }, // a socket is opened
        close(ws, code, message) { }, // a socket is closed
        drain(ws) { }, // the socket is ready to receive more data
    },
});
"""
}

