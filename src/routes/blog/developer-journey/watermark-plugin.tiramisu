title { Watermark Plugin }

My goal as the new DevRel engineer is to learn and build in public, creating
useful examples along the way. That's why my next project is to build an image
watermarking plugin.

This project is a perfect choice for a few reasons:

list {
    items = bold { Working with Files }: 
    I want to learn how to handle different data types specifically image files
    in Sia.,
    items = bold { A Useful Function }:
    Watermarking is a genuinely useful function that anyone from small
    businesses to individual creators can use. A good real use case example for
    a plugin.,
    items = "This plugin perfectly demonstrates the purpose of Timeleap's
    distributed network. You can create a powerful plugin, add it to a subnet,
    and set a fee for its usage. Other developers can then tap into the
    network's computation power to use your function for their own needs,
    turning your code into a monetized application."
}

In this article, I'll take you through my journey of building this plugin, from
my initial learning to the final implementation.

title { My Journey: A Learning Log, size = 2 }

list {
    items = bold { Understanding the Core Task }: 
    "Before writing any code, I need a clear picture of how image watermarking
    works. I'll be using Sharp.js to generate text as SVGs and then apply them
    as watermarks",
    items = bold { Schema Definition }:
    "The first piece of code I'll write is the Sia schema for the plugin. This
    is the contract that defines what the plugin does. It must accept
    the image data and the watermark text as arguments and return the
    watermarked image file. I'll share my draft schema here and explain the
    reasoning behind each data type."
}

code {
    language = sia,
    content = """
    schema Args {
        text   string8(encoding = "ascii")
        location string8(encoding = "ascii")
        image byte32
    }

    schema Fee {
        amount     uint64
        currency   string8(encoding = "ascii")
    }

    schema WatermarkImageCall {
        uuid    byte8
        plugin  string8(encoding = "ascii")
        method  string8(encoding = "ascii")
        timeout uint64
        fee     Fee
        args    Args
    }

    schema WatermarkImageResponse {
        opcode    uint8
        appId     uint64
        uuid      byte8
        error?    uint16
        ok?       bool
        watermarkedImage?  byte32
    }


    plugin swiss.timeleap.watermarker as WatermarkImage {
        method addWatermarkToImage(timeout = 5000, fee = 1, currency = "USD") Args returns {
            ok bool
            watermarkedImage byte32
        }
    }
"""
}

Similar to link { to = /blog/developer-journey/hello-world-timeleap-app,
hello-world }, we need args, fee, call, and response. These define what we
expect: the watermark text, the image, and the position where the user wants the
watermark applied. Once defined, we add the args and fee to the call. Later on,
we can extend this into the tlp CLI. By default, a plugin schema should contain
inlineCode { args, fee, call, response }. We'll return to the tlp CLI later in
the article.

title { Building the Plugin, size = 3 }

This is where the core logic goes. I'll implement the inlineCode {
addWaterMarkToImage } function, which takes the input image and text, applies
the watermark using my chosen library, and returns the result.

I used tlp CLI to install and run the Timeleap broker and worker in the
inlineCode { ./timeleap } directory of my project. Next, I need to implement the
plugin. Following the example plugins repository, I'm using Bun and workspaces
since I'll also be building the client. The Sia-generated code needs to be
usable by both the plugin and the client, so I created a shared folder with a
models directory and added a simple package.json:

code {
    language = json,
    content = """
    {
     "name": "@shared/models",
     "version": "1.0.0",
     "main": "index.ts"
    }
"""
}

And added it inside the bun workspaces in the root inlineCode { package.json }.
and put the Sia model and the generated code inside of inlineCode { models }.

Did this the same for the plugin as well.

We need to think about what we need in the plugin code, First, we need to have a
wallet and identity for our plugin, so we can sign the responses we give. To do
that, we need to do two things:

First, we need to install the SDK. I did it inside the root directory with:

code {
    language = bash,
    content = """
    bun install @timeleap/client --dev
    """
}

Then we need the worker's public key, which we can get from
inlineCode { ./timeleap/secrets/worker_secrets.yaml }
but we need to generate an identity for the plugin. To do that, we use Timeleap
SDK once again, so I made a utils folder inside pluign directory and added this:

code {
    language = typescript,
    content = """
	import { Wallet } from '@timeleap/client';

	const wallet = await Wallet.random();
	const encoded = wallet.toBase58();

	console.log('sk:', encoded.privateKey);
	console.log('pk:', encoded.publicKey);
"""
}
