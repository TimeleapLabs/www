title { Timeleap: The Communication Protocol }

So, we've talked about Timeleap giving you the tools to create a distributed
computation network. In this article, we are connecting the dots: Timeleap, Sia,
and the rules of the network. What does every network have? A protocol!

Think of protocol as the complete rule book for every communication in the
network. Timeleap has created its communication protocol to ensure that every
message is reliable, secure, and fast. And as it was mentioned before, you don't
have to build the protocol from scratch. Our broker-worker model already
implemented it for you.

Here's a breakdown of the Timeleap protocol:

list {
    items = bold { Communication: The WebSocket }: The protocol dictates that
    all communication on the network happens over a persistent WebSocket
    connection (for now). This long-lived open channel allows nodes to
    constantly talk to each other.,
    items = bold { Serialization: Sia the Sonic }: Every message that travels
    through these WebSocket connections is formatted using our fast
    serialization library: Sia. The protocol standardizes this ensuring every
    packet is as small and efficient. Sia also allows working with different
    types even the custom ones more easily.,
    items = bold { Packet Structure: The Blueprint }: The protocol defines a
    schema-driven structure for every packet which you can check out 
    link { to = /docs/reference/packets, here }
}

title { The Packet, size = 2 }

Every task on the network is assigned a UUID, which helps to identify and
track it. All messages are then wrapped in a signed packet, which acts as an
outer envelope to ensure the message's authenticity and integrity. This packet
includes:

list {
    items = inlineCode { OpCode }: A code that tells the network what kind of
    task or message this is.,
    items = inlineCode { AppID }: A unique identifier of the network, along
    with other measures, helps protect against a replay attack.,
    items = inlineCode { Signer } and inlineCode { Signature }: This is the most
    crucial part for security. We use bold { Ed25519 } for our cryptographic
    signatures. The inlineCode { Signer } identifies who sent the message and
    the inlineCode { Signature } is the cryptographic proof that it came from
    them and hasn't been tampered with.
}

So, how is the protocol used in the broker-worker and plugin ecosystem? For each
type of task, the protocol defines a specific packet structure i.e inlineCode {
OpCode }. For example with plugins the protocol specifies an inlineCode {
RPCRequest } packet that includes details like the plugin name, method, fee, and
currency.

We have a Timeleap SDK for TypeScript that handles this stuff for our dear
Timeleap app developers. For instance, using our TypeScript SDK, you can make a
client to call a broker like this:

code {
    language = typescript,
    content = """
    const myWallet = await Wallet.random() // Identity 
    const client = await Client.connect(myWallet, {
        uri: process.env.BROKER_URI,
        publicKey: process.env.BROKER_PUBLIC_KEY,
    })

    const siaPayload = Sia.alloc(512)
    .addUInt8(OpCodes.Message)
    .addUInt64(client.appId)
    .addByteArray8(uuidv7obj().bytes)
    .addString8("Hello from my client!");

    const response = await client.send(siaPayload);
"""
}