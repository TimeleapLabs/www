title { Timeleap: The Communication Protocol }

We've talked about Timeleap giving you the tools to create a distributed
computation network link { to =
/blog/develeoper-journey/introduction-to-timeleap, here}. In this article, we
are connecting the dots: Timeleap, Sia, and the rules of the network.

Think of Timeleap protocol as the complete rule book and blueprint to implement
what we call a inlineCode { Timeleap App }. Timeleap has created its
communication protocol to ensure not only that every message is reliable,
secure, and fast, but also to ensure reproducibility and compatibility in
different implementations. We have a reference implementation of this blueprint,
which is our broker-worker model. Others can study the blueprint and implement
their own, which you can check out link { to =
https://github.com/TimeleapLabs/timeleap, here }.

Here's a breakdown of the Timeleap protocol:

list {
    items = bold { Communication: The WebSocket }:
    The protocol dictates that all communication on the network happens over a
    persistent WebSocket connection. This long-lived open channel
    allows nodes to constantly talk to each other.,
    items = bold { Serialization: Sia the Sonic }:
    Every message that travels through these WebSocket connections is formatted
    using our fast serialization library: Sia. The protocol standardizes this
    ensuring every packet is as small and efficient. Sia also allows working
    with different types even the custom ones more easily.,
    items = bold { Packet Structure: The Blueprint }:
    The protocol defines a schema-driven structure for every packet which you
    can check out link { to = /docs/reference/packets, here }.
}

title { The Packet, size = 2 }

Every request on the network is assigned a UUID, which helps to identify and
track it. All messages are then wrapped in a signed packet, which acts as an
outer envelope to ensure the message's authenticity and integrity. This packet
includes:

list {
    items = inlineCode { OpCode }: 
    A code that tells the network what kind of task or message this is.,
    items = inlineCode { AppID }:
    A unique identifier of the network along with other measures it helps
    protect against a replay attack.,
    items = inlineCode { Message }:
    This is where the packet's data is stored, which is Sia-encoded.
    items = inlineCode { Signer } and inlineCode { Signature }: 
    This is the most crucial part for security. We use bold { Ed25519 } for our
    cryptographic signatures. The inlineCode { Signer } identifies who sent the
    message and the inlineCode { Signature } is the cryptographic proof that it
    came from them and hasn't been tampered with.
}

So, how is the protocol used in the broker-worker and plugin ecosystem? For each
type of request, i.e inlineCode { OpCode }, the protocol defines a specific
packet structure. For example, with plugins, the protocol specifies an
inlineCode { RPCRequest } packet that includes details like the plugin name,
method, fee, and currency.

We have a Timeleap SDK for TypeScript that handles this stuff for our dear
Timeleap app developers. For instance, using our TypeScript SDK, you can make a
client to call a broker like this:

code {
    language = typescript,
    content = """
	const myWallet = await Wallet.random(); // Identity
	const client = await Client.connect(myWallet, {
		uri: process.env.BROKER_URI,
		publicKey: process.env.BROKER_PUBLIC_KEY
	});

	const siaPayload = Sia.alloc(512)
		.addUInt8(OpCodes.Message)
		.addUInt64(client.appId)
		.addByteArray8(uuidv7obj().bytes)
		.addString8('Hello from my client!');

	const response = await client.send(siaPayload);
"""
}

In this example, the inlineCode { Wallet } is not a traditional crypto or
Web3 wallet. It's a simple key pair that provides a cryptographic identity for
your client, allowing it to sign and authenticate messages on the network.

So to see this in action, I cloned the Timeleap repo and started a broker, and
just used its URL and public key to connect to it, the little inlineCode { New
client connected } means that our operation was successful, and since no worker
or plugin is running, our operation doesn't do anything else.

image {
  src = /images/blog/dev-journey/timeleap-client-example.png,
  alt = Timeleap SDK client connecting to the broker,
  caption = Small demonstration of using SDK to connect to a broker.
}

This was just experimental; when we develop plugins later, we will link { to =
https://x.com/Bluerosedev/status/1956467618887397605, Dockerize! }.

title { Error and Task Management, size = 2 }

The protocol also outlines rules for what to do when things don't go as planned.
For example, inlineCode { OpCode } is not only for determining the task type,
but it can also determine if a task failed, like inlineCode { OpCodeTaskFailed }
or if a worker is overloaded and can't work anymore, we have inlineCode {
OpCodeWorkerOverload }.

title { Plugin Support, size = 2 }

You can even generate your plugin's methods directly from a Sia schema:

code {
    language = sia, 
    content = """
    plugin swiss.timeleap.isWizard.v1 as Sorcery {
        method isWizard(timeout = 5000) IsWizardArgs returns WizardResponse
    }
"""
}

When I had enough knowledge about how the protocol works under the hood, and I
saw this, I was blown away by how simple you can send a request to the plugin
method:

code {
    language = typescript, 
    content = """
    const response = await sorcery.isWizard({ name: "Haned", age: 23 });
"""
}

title { Conclusion }

That's the Timeleap protocol. It's the simple rule book that makes the
network fast and secure. With WebSockets and Sia, messages fly. The SDK does all
the heavy lifting for you, so you can just focus on building. Next, we'll see a
full Timeleap app in action.

meta {
    description = "Learn how the Timeleap protocol enables fast and secure communication using WebSockets, Sia serialization, and signed packets.",
    ogImageText = [Timeleap, Protocol],
    ogImageFontSize = 36,
    author = hamed,
    createdAt = 2025-08-28
}

