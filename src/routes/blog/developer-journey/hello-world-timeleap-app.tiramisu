title { Hello World: introduction to Timeleap Apps }

alert { type = info, This article assumes some familiarity with: Sia, Sia
Schema, and the Timeleap protocol. }

In this article, we'll walk through a simple inlineCode { hello-world } Timeleap
app to visually demonstrate the concepts we've discussed. The full code for this
example is available on link { to =
https://github.com/TimeleapLabs/plugins/hello-world, Github }.

Our app uses Timeleap tools for its internal communication. For the user, it's a
straightforward command-line application: you input a text string, and it
returns the same string. The magic happens behind the scenes, with four key
components working together in a containerized Docker environment: a bold {
plugin }, a bold { broker }, a bold { worker }, a bold { client } and a small
bold { CLI app }.

Let's begin with the starting point: the Client.

title { The Client: Making the Connection, size = 2 }

The CLI app takes your input and sends it to the client. The client's main job
is to call a specific function inside the plugin. Before it can do that, it must
first establish a secure connection.

Here is the function that handles this connection:

code { 
    language = typescript,
    content =  """
	import { Client, Wallet } from '@timeleap/client';
	import { HelloWorld } from '@repo/models';
	import { Sia } from '@timeleap/sia';

	const createClient = async () => {
		const wallet = await Wallet.random();
		const client = await Client.connect(wallet, {
			uri: process.env.BROKER_URI,
			publicKey: process.env.BROKER_PUBLIC_KEY
		});
		const hello = HelloWorld.connect(client);

		return { client, hello };
	};
"""
}

This simple function sets up the entire foundation for our app's communication.
It:

list {
    type = ordered,
    items = bold { Creates a } inlineCode { Wallet }: 
    This generates a inlineCode { Wallet } instance which is our client's
    cryptographic identity on the network.,
    items = bold { Connects to the } inlineCode { Broker }: 
    It then uses that identity to securely connect to the broker which acts as
    the central orchestrator for our network.,
    items = bold { Connects to the Plugin }:
    Finally it connects to the inlineCode { HelloWorld } plugin making its
    functions available to our client.
}

title { The Sia Schema: The Blueprint of Communication, size = 3 }

This is the most important part of the process. The entire communication between
the client and the worker is defined and enforced by a Sia Schema. This schema
acts as a contract, ensuring that all data sent and received is in the correct
format. The plugin's functions themselves can be generated directly from this
schema, which we explained link { to = /blog/developer-journey/sia-schema, here
}.

Here is the schema for our inlineCode { hello-world } app:

code {
    language = sia,
    content = """
    schema Args {
        message   string8(encoding = "ascii")
    }

    schema Fee {
        amount     uint64
        currency   string8(encoding = "ascii")
    }

    schema HelloWorldCall {
        uuid    byte8
        plugin  string8(encoding = "ascii")
        method  string8(encoding = "ascii")
        timeout uint64
        fee     Fee
        args    Args
    }

    schema HelloWorldResponse {
        opcode    uint8
        appId     uint64
        uuid      byte8
        error?    uint16
        ok?       bool
        message?  string8(encoding = "ascii")
    }

    plugin swiss.timeleap.helloWorld as HelloWorld {
        method hi(timeout = 5000, fee = 1, currency = "USD") Args returns {
            ok      bool
            message string8(encoding = "ascii")
        }
    }
"""
}

As you can see, this schema defines the structure of the messages, the fees, and
the methods that our inlineCode { hello-world } plugin exposes, right down to
the argument and return types. The client and worker both use this schema to
ensure they are speaking the same language.

title { The Plugin: The Application Logic, size = 3 }

The plugin is where the core logic of our application lives. In our 
inlineCode { hello-world } app, it's a simple Bun.js server that listens for a
WebSocket message from the broker, processes it, and sends back a response.

This code snippet shows how it works:

code {
    language = typescript,
    content = """
    const worker = await Identity.fromBase58(process.env.WORKER_PUBLIC_KEY);
    const wallet = await Wallet.fromBase58(process.env.PLUGIN_PRIVATE_KEY);
    const appId = process.env.APP_ID ?? 0;

    Bun.serve({
        port: 80,
        fetch(req, server) {
            if (server.upgrade(req)) return;

            return new Response('upgrade failed', { status: 500 });
        },
        websocket: {
            open() {
                console.info('Broker is connected!');
            },
            async message(ws, message: Buffer) {
                // 1. Verify the signature.
                if (!(await worker.verify(message))) {
                    console.error('Invalid signature');
                    return;
                }

                // 2. Decode the incoming message using the Sia Schema.
                const { uuid, plugin, method, args } = decodeHelloWorldCall(
                    // Skipping the first 9 bytes (the opcode and appId)
                    new Sia(message).skip(9) 
                );
                // It also checks if the message was for this plugin's method
                // It wasnt provided here for favor of a smaller code block

                // 3. Sign the payload that we are sending back.
                const response = await wallet.signSia(
                    // 4. Encode the response back using the Sia Schema.
                    encodeHelloWorldResponse(Sia.alloc(512), {
                        opcode: OpCodes.RPCResponse,
                        appId,
                        uuid,
                        ok: true,
                        message: args.message
                    })
                );

                // 5. Send the response back to the client.
                ws.send(response.toUint8ArrayReference());
            }
        }
    });
"""
}

This code snippet is the worker's functionality that is attached to it, a
inlineCode { Plugin }. It shows a series of steps that happen every time a
request comes in: it verifies the request, decodes it using the schema,
processes the logic, and encodes and sends the response back.

title { The Full Circle: From Client to Worker and Back, size = 3 }

image {
    src = /images/blog/dev-journey/hello-world-sketch.png ,
    alt = A diagram-like sketch of how the flow of hello-world start froms cli,
    goes to the client and then to broker, worker and then plugin and returns.,
    caption = How request flows through the hello-world Timeleap App.
}

Once the client calls a function on the plugin, a series of events happen:

list {
    type = ordered,
    items = The broker receives the client's request.,
    items = The broker redirects the request to the worker that has the
    requested plugin attached.,
    items = The worker executes the function.,
    items = The worker sends the response back to the broker.,
    items = The broker then delivers the response back to the client.,
    items = Finally the client returns the result to the user.
}

This entire process happens very fast, thanks to the efficiency of the Sia
serialization library. The combination of lightweight data structures and
cryptographic verification ensures that messages are small, fast, and secure
from end to end.

title { Conclusion }

In this article, we've broken down the core components of a Timeleap app and
seen how they communicate to execute a simple task. We explored the roles of the
client, broker, and worker.

You might be wondering, "" "How do I get started and set all of this up? the
worker, the broker, and everything in between?" "" The good news is, you don't
have to. Next, we'll explore the inlineCode { tlp } CLI, a tool that automates
all these steps for you, making for a great developer experience. We'll use it
to build our very first plugin, taking our developer journey to the next level.