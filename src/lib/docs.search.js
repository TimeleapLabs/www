export default [
  {
    "text": "These are the official Kenshi community links:\nTelegram\nTwitter\nReddit\nMedium\nForum\nGitHub\nDiscord\nZealy\nKenshi does not have any other online or offline communities except\nthe ones listed above. Be extra cautious when joining other unofficial\ncommunities. Always remember this: we will never contact you first.\nFor business enquiries, send us a message at hi@kenshi.io.",
    "breadcrumb": [
      {
        "url": "/docs",
        "title": "Documentation"
      },
      {
        "url": "/docs/community",
        "title": "Community"
      }
    ]
  },
  {
    "text": "Kenshi is a Japanese given name that has multiple meanings\ndepending on how it is written.\nSwordsman is the meaning based on which we chose this name.\nWe're located in Lausanne, Switzerland.\nNo. We took the official Binance BEP-20 token template, updated\nit to the latest Solidity version and wrote all custom functionalities\nfrom scratch.",
    "breadcrumb": [
      {
        "url": "/docs",
        "title": "Documentation"
      },
      {
        "url": "/docs/faq",
        "title": "FAQ"
      }
    ]
  },
  {
    "text": "Entrepreneur, developer and innovator with a passion for distributed and decentralized systems.\nFounder at Kenshi, Clio programming language, and CTO at Equip.\nCEO at Nidecker Group, LPS and Equip. Entrepreneur in sport & tech. Partner to awesome\nstartups & relentless optimist. Growing internationally +10 brands with a team 100+ people.\nData science professional with over 12 years of experience in applying machine learning\nand cryptography in a diverse range of industries. She previously worked at IBM Research\nand holds multiple patents for her scientific work.\nFull-stack developer with a passion for cybersecurity and crypto-assets.\nHe has been growing online businesses for the last 3 years and is proficient in design,\nmarketing and deploying complex infrastructures.",
    "breadcrumb": [
      {
        "url": "/docs",
        "title": "Documentation"
      },
      {
        "url": "/docs/team",
        "title": "Team"
      }
    ]
  },
  {
    "text": "There is a private key hidden in the image below, find it and the prize is yours.\nThere are 2 billion Kenshi tokens in this wallet and enough gas to withdraw them.\nThe wallet is excluded from fines.\nCongratulations to Zert for solving this puzzle! Details on how the puzzle was created,\nand how it was solved will be published soon.",
    "breadcrumb": [
      {
        "url": "/docs",
        "title": "Documentation"
      },
      {
        "url": "/docs/puzzles",
        "title": "Puzzles"
      },
      {
        "url": "/docs/puzzles/1",
        "title": "First Puzzle (24 Jun 2022)"
      }
    ]
  },
  {
    "text": "In the rapidly evolving world of blockchain technology, Kenshi stands at the\nforefront as a pioneering innovator. Founded in December 2021 and nestled in the\nheart of Switzerland, we are a company driven by a mission to foster the\nconvergence of the traditional web (Web 2.0) and the decentralized future (Web\n3.0). Our commitment to innovation and excellence fuels our dedication to\nproviding cutting-edge blockchain solutions.\nOur flagship offerings reflect our understanding of the digital landscape and\nour vision for its future. The Kenshi Oracle Network, a serverless,\nasynchronous, and fault-tolerant framework, redefines the possibilities for\ncreating, deploying, and operating custom oracles on EVM-based blockchain\nnetworks. It is a testament to our technical expertise and drive to push the\nboundaries of what's possible in the blockchain space.\nComplementing this is our powerful blockchain data indexing and processing\nsolution - Kenshi Deep Index. It provides full-stack data consumption, enabling\nefficient event management on the blockchain. With a suite of tools such as Deep\nIndex Sync, Deep Index GraphQL, Deep Index MQL, and Deep Index R-API, we make it\neasier to manage, query, and analyze blockchain data.\nWe also recognize the growing importance of IoT in the modern world. To this\nend, we've developed the Kenshi Blockchain IoT SDK, which allows embedded\ndevices to receive and process blockchain events efficiently. This innovation\npaves the way for seamless integration between IoT and connected systems,\nfurther bridging the gap between the traditional web and the decentralized\nfuture.\nAt Kenshi, we strive to stay ahead of the curve. Our solutions are a testament\nto our forward-thinking approach, technical expertise, and commitment to\nrevolutionizing how the world interacts with the blockchain. We invite you to\njoin us on this exciting journey into the future of the decentralized web.\nKenshi provides the following services:\nDeep Index: Allows indexing blockchain events for blazing-fast access.\nIoT SDK: Allows receiving blockchain events on IoT devices.\nOracle Network: Allows creating custom oracles.",
    "breadcrumb": [
      {
        "url": "/docs",
        "title": "Documentation"
      },
      {
        "url": "/docs/kenshi",
        "title": "What is Kenshi?"
      }
    ]
  },
  {
    "text": "Kenshi logos and artwork:\nA brief description of Kenshi and its services can be found in the\nabout Kenshi document.\nYou can download our press kit (Logos and documents)\nhere.\nKenshi uses the Carbon Design System.",
    "breadcrumb": [
      {
        "url": "/docs",
        "title": "Documentation"
      },
      {
        "url": "/docs/media",
        "title": "Media"
      }
    ]
  },
  {
    "text": "There is a private key hidden in this puzzle, find it and the prize is yours.\nThere are 200,000 Kenshi tokens in this wallet and enough gas to withdraw them.\nYou can check the Kenshi balance of the wallet on the Kenshi\ntools page.\nIf the wallet is not empty it means the contest is still ongoing.\nGood luck!\nThe album art for the above file can be downloaded separately:",
    "breadcrumb": [
      {
        "url": "/docs",
        "title": "Documentation"
      },
      {
        "url": "/docs/puzzles",
        "title": "Puzzles"
      },
      {
        "url": "/docs/puzzles/2",
        "title": "Second Puzzle (15 Feb 2023)"
      }
    ]
  },
  {
    "text": "The Kenshi referral program is to promote Kenshi products and services\nthrough a network of tech influencers, business partners and individuals.\nThe referral program does not apply to the Kenshi token.\nVideos, articles, graphics or short pieces of texts (e.g. a tweet) qualify\nas promotional content if they:\nIntroduce Kenshi's services and products, or\nShow the use case of Kenshi products and services, or\nTeach users how to use the Kenshi products, or\nAre of other educational nature about Kenshi's tech\nBusiness partners listing Kenshi on their website and actively using our\nproducts for their clients qualify to earn commissions on their referrals.",
    "breadcrumb": [
      {
        "url": "/docs",
        "title": "Documentation"
      },
      {
        "url": "/docs/refer",
        "title": "Referral program"
      }
    ]
  },
  {
    "text": "Here you can find various Kenshi puzzles to solve and win prizes.\nSecond Puzzle (15 Feb 2023)\nFirst Puzzle (24 Jun 2022)",
    "breadcrumb": [
      {
        "url": "/docs",
        "title": "Documentation"
      },
      {
        "url": "/docs/puzzles",
        "title": "Puzzles"
      }
    ]
  },
  {
    "text": "Unchained is released under BUSL 1.1 License with the following use grants:\nOfficial Networks : You may run Unchained to join the official Unchained\nmainnet or testnet networks.\nNon-commercial : You may run Unchained as a private network, local network,\nor an independent application for non-commercial use cases.\nSmall Businesses : You may run Unchained as a private network, local network,\nor an independent application if your annual revenue is under 100,000 CHF.\nContact us for a license or agreement for any other use case.\nRead the full license text\nhere.\nThe entire Unchained software source code is available to be viewed or modified to\nyour specific use cases. All code is open sourced under AGPL 3.0 after 10 years of\nrelease.",
    "breadcrumb": [
      {
        "url": "/docs",
        "title": "Documentation"
      },
      {
        "url": "/docs/unchained",
        "title": "Unchained"
      },
      {
        "url": "/docs/unchained/license",
        "title": "License"
      }
    ]
  },
  {
    "text": "The example below shows a Sync task to sync all Kenshi token transfer events into the Kenshi\nblockchain data clusters:",
    "breadcrumb": [
      {
        "url": "/docs",
        "title": "Documentation"
      },
      {
        "url": "/docs/services",
        "title": "Services and Products"
      },
      {
        "url": "/docs/services/deep-index",
        "title": "Deep Index"
      },
      {
        "url": "/docs/services/deep-index/sync",
        "title": "Deep Index Sync"
      },
      {
        "url": "/docs/services/deep-index/sync/example",
        "title": "Deep Index Example"
      }
    ]
  },
  {
    "text": "Instead of querying the blockchain or the Kenshi GraphQL endpoint, you can get the\nevents delivered to your application instead. This allows creating a completely serverless\nflow of receiving and processing the blockchain data.\nThe Kenshi Reverse-API service allows you to input a contract address, contract ABI, a starting block\nand an API endpoint (your HTTPS endpoint, AWS Lambda function...). Every time an event is emitted by\nyour contract address the Reverse-API service sends it to your endpoint.\nTo use this service head to the Kenshi dashboard, connect\nyour wallet and register an endpoint using the new Reverse-API form. Continue reading on to\nget help with the dashboard or see examples of the Reverse-API service.",
    "breadcrumb": [
      {
        "url": "/docs",
        "title": "Documentation"
      },
      {
        "url": "/docs/services",
        "title": "Services and Products"
      },
      {
        "url": "/docs/services/deep-index",
        "title": "Deep Index"
      },
      {
        "url": "/docs/services/deep-index/webhook",
        "title": "Reverse API for Deep Index"
      },
      {
        "url": "/docs/services/deep-index/webhook/introduction",
        "title": "Introduction to R-API"
      }
    ]
  },
  {
    "text": "Below you can find the Kenshi Reverse-API request body schema.",
    "breadcrumb": [
      {
        "url": "/docs",
        "title": "Documentation"
      },
      {
        "url": "/docs/services",
        "title": "Services and Products"
      },
      {
        "url": "/docs/services/deep-index",
        "title": "Deep Index"
      },
      {
        "url": "/docs/services/deep-index/webhook",
        "title": "Reverse API for Deep Index"
      },
      {
        "url": "/docs/services/deep-index/webhook/schema",
        "title": "R-API Schema"
      }
    ]
  },
  {
    "text": "Kenshi R-API integrates with all the existing automation and data flow\ntools that support webhooks. Some examples include AWS Lambda, Zapier,\nIFTTT, make.io, and automate.io.\nComing soon.",
    "breadcrumb": [
      {
        "url": "/docs",
        "title": "Documentation"
      },
      {
        "url": "/docs/services",
        "title": "Services and Products"
      },
      {
        "url": "/docs/services/deep-index",
        "title": "Deep Index"
      },
      {
        "url": "/docs/services/deep-index/webhook",
        "title": "Reverse API for Deep Index"
      },
      {
        "url": "/docs/services/deep-index/webhook/integrations",
        "title": "Integrations"
      }
    ]
  },
  {
    "text": "The Kenshi Deep Indexing MQL service is your gateway to query the blockchain data\nstored on the Kenshi blockchain data clusters. This endpoint implements the standard\nMQL specification and is accessible over the HTTP protocol using POST requests.\nTo use the MQL service, you will need an API key. To create an API key you can visit\nthe Kenshi dashboard. Continue reading on to get\nhelp with the dashboard or see examples of the Sync service.",
    "breadcrumb": [
      {
        "url": "/docs",
        "title": "Documentation"
      },
      {
        "url": "/docs/services",
        "title": "Services and Products"
      },
      {
        "url": "/docs/services/deep-index",
        "title": "Deep Index"
      },
      {
        "url": "/docs/services/deep-index/mql",
        "title": "MQL (MongoDB Query Language) for Deep Index"
      },
      {
        "url": "/docs/services/deep-index/mql/introduction",
        "title": "Introduction to MQL"
      }
    ]
  },
  {
    "text": "Sync tasks are essential to the Kenshi Deep Indexing ecosystem. These tasks run periodically,\nfetching events from the blockchain and storing them into the Kenshi blockchain data clusters.\nThis information can then be queried using the Kenshi GraphQL API, or you can choose to be\nnotified of them using the Kenshi Reverse-API (Webhooks) service.\nData stored in the Kenshi blockchain data cluster is shared with all Kenshi clients. If there\nis already a Sync task targeting the blockchain data you are interested in, you won't have to\ncreate a sync task yourself. To check whether the data you are interested in already exists on\nthe Kenshi blockchain data clusters simply make a GraphQL request to our API address, or ask\nthe project owners if they have already created a task and if they provide a Kenshi GraphQL API\nkey for public access.\nThe Kenshi Deep Index Sync task service is fully managed and does not require any external\nservers or setup. To use it head to the Kenshi dashboard, connect your wallet\nand make a task using the new Sync task form.\nContinue reading on to get help with the dashboard or see examples of the Sync service.",
    "breadcrumb": [
      {
        "url": "/docs",
        "title": "Documentation"
      },
      {
        "url": "/docs/services",
        "title": "Services and Products"
      },
      {
        "url": "/docs/services/deep-index",
        "title": "Deep Index"
      },
      {
        "url": "/docs/services/deep-index/sync",
        "title": "Deep Index Sync"
      },
      {
        "url": "/docs/services/deep-index/sync/introduction",
        "title": "Introduction to Deep Index Sync"
      }
    ]
  },
  {
    "text": "The Kenshi Deep Index endpoint for MQL shares the same endpoint\nfor all blockchains and all event types:",
    "breadcrumb": [
      {
        "url": "/docs",
        "title": "Documentation"
      },
      {
        "url": "/docs/services",
        "title": "Services and Products"
      },
      {
        "url": "/docs/services/deep-index",
        "title": "Deep Index"
      },
      {
        "url": "/docs/services/deep-index/mql",
        "title": "MQL (MongoDB Query Language) for Deep Index"
      },
      {
        "url": "/docs/services/deep-index/mql/endpoints",
        "title": "MQL Endpoints"
      }
    ]
  },
  {
    "text": "You can find the below examples on Github.\nKenshi provides a simple IoT SDK example for controlling LEDs using blockchain events on Arduino\nboards. You can find the sketch and the smart contracts\nhere.\nKenshi provides a simple IoT SDK example for controlling LEDs using blockchain events on ESP32\nboards. You can find the sketch and the smart contracts\nhere.\nKenshi provides a simple IoT SDK sample app for the Zephyr RTOS. The sample app receives\na blockchain event and prints the results to the console. You can find the sketch and the\nsmart contracts\nhere.\nThis app is only tested on ESP32 DevkitC! You might need to make a few\nmodifications for it to work on your board.",
    "breadcrumb": [
      {
        "url": "/docs",
        "title": "Documentation"
      },
      {
        "url": "/docs/services",
        "title": "Services and Products"
      },
      {
        "url": "/docs/services/iot",
        "title": "Kenshi IoT SDK"
      },
      {
        "url": "/docs/services/iot/examples",
        "title": "IoT SDK Examples"
      }
    ]
  },
  {
    "text": "Kenshi Oracle Network takes care of the following for your oracles:\nEvent Sourcing:  Kenshi uses the same asynchronous, serverless technology as the Kenshi Deep index\nto source blockchain events for your oracle. The only difference is that the events are not indexed, but\nare sent directly to your oracle to be processed.\nCaching:  Kenshi caches your events in memory (Memcached with a TTL of 900s) to prevent a request\nfrom being processed twice.\nGas Station:  Kenshi calculates the gas fee to fulfil the requests to your oracle with a \"fast\"\ntransaction.\nDelivery:  Kenshi makes sure your data is delivered to the blockchain. There are a total of 10\nretries in case something goes wrong with your request.\nNonce Management:  Kenshi manages the \"nonce\" of the gas wallet associated with your oracle. Nonces\nneed to be unique and in sequential order; blockchain doesn't support the concept of parallel processing.\nKenshi Nonce Manager keeps your transactions in order and makes sure nonces are not skipped.\nWith the Oracle Network, you can use the technology of your choice to develop your oracle, as long as you\nimplement the Kenshi Custom Oracle Protocol.",
    "breadcrumb": [
      {
        "url": "/docs",
        "title": "Documentation"
      },
      {
        "url": "/docs/services",
        "title": "Services and Products"
      },
      {
        "url": "/docs/services/oracle-network",
        "title": "Oracle Network"
      },
      {
        "url": "/docs/services/oracle-network/custom",
        "title": "Custom Oracles"
      },
      {
        "url": "/docs/services/oracle-network/custom/features",
        "title": "Features"
      }
    ]
  },
  {
    "text": "Hardware requirements vastly differ depending on the selected features,\ndatasets, client roles, or the client libraries used. Technically speaking, any\ndevice capable of signing a BLS12-381 message is capable of being an Unchained\nnode. See for example, \"BLS12-381 Pairing Implementation with RAM Footprint Smaller than 4KB\".\nTo run the Unchained Go client in different modes, you'll need the following\nhardware specs:\nPlease note that the above values are the  minimum  recommended levels.\nAs the network grows, the requirements for running nodes will change as well.\nLearn more about GiB vs GB here.\nIf you're planning to run a Worker node with AI capabilities, you'll need to\nhave a powerful GPU. The requirements will be updated once AI support lands into\nUnchained.",
    "breadcrumb": [
      {
        "url": "/docs",
        "title": "Documentation"
      },
      {
        "url": "/docs/unchained",
        "title": "Unchained"
      },
      {
        "url": "/docs/unchained/nodes",
        "title": "Running a Node"
      },
      {
        "url": "/docs/unchained/nodes/hardware-requirements",
        "title": "Hardware Requirements"
      }
    ]
  },
  {
    "text": "The metadata API endpoint can be used to get sync status of your sync tasks.\nTo get this info, make a GET request to the following url, replacing\n{TASK_ID} with your task ID.",
    "breadcrumb": [
      {
        "url": "/docs",
        "title": "Documentation"
      },
      {
        "url": "/docs/services",
        "title": "Services and Products"
      },
      {
        "url": "/docs/services/deep-index",
        "title": "Deep Index"
      },
      {
        "url": "/docs/services/deep-index/sync",
        "title": "Deep Index Sync"
      },
      {
        "url": "/docs/services/deep-index/sync/metadata",
        "title": "Metadata API"
      }
    ]
  },
  {
    "text": "The Kenshi Deep Indexing GraphQL service serves as your gateway to efficiently\nquery blockchain data stored within Kenshi's blockchain data clusters. Adhering\nto the standard GraphQL specification, this user-friendly endpoint is accessible\nvia HTTP protocol using POST requests, streamlining data retrieval and\nmanagement in the blockchain ecosystem.\nTo use the GraphQL service, you will need an API key. To create an API key, visit\nthe Kenshi dashboard. Continue reading to get help\nwith the dashboard or see examples of the Sync service.",
    "breadcrumb": [
      {
        "url": "/docs",
        "title": "Documentation"
      },
      {
        "url": "/docs/services",
        "title": "Services and Products"
      },
      {
        "url": "/docs/services/deep-index",
        "title": "Deep Index"
      },
      {
        "url": "/docs/services/deep-index/graphql",
        "title": "GraphQL for Deep Index"
      },
      {
        "url": "/docs/services/deep-index/graphql/introduction",
        "title": "Introduction to GraphQL"
      }
    ]
  },
  {
    "text": "To get started with the Kenshi Deep Indexing Sync tasks, go to the Kenshi dashboard and\nconnect your wallet. Then click on the “New Sync Task” button and fill in the “New Deep\nIndexing Task” form.\nThe Sync task form lets you choose what blockchain data is relevant to you. How you fill the\nform depends on your use case, but we can give you some tips and info about each one of the\nfields in this form.\nChain : Here you need to choose the chain where your data is. For example, if you\ndeployed your smart contract to the Fantom chain and you want to sync the events from\nthis smart contract to the Kenshi blockchain data clusters, then you'll need to choose\nthe Fantom chain here. This value cannot be changed after the task is created.\nStarting block : This field specifies from which block the sync task should look\nfor the events you want to sync. Following the example of the  Chain  field, if your\nsmart contract is deployed at block XYZ (eg. block 39176717) you'd want to put that number\nin this field. This value cannot be changed after the task is created.\nDuration : This field defines how many month should the service run. You can extend\nthe Sync duration, but you cannot cancel or end the task.\nContract address : The source of the events you want to sync to the Kenshi blockchain\ndata clusters. This is usually the address of your smart contract, or the smart contract\nthat emits the events you are looking for.\nContract ABI : Put ABI of the smart contract (from the  Contract address ) field here.\nYou can either put the entire ABI, or just include the ABI of the events you are interested in.\nThe ABI can be Human-Readable ABI or the ABI emitted by the Solidity compiler, in JSON format.",
    "breadcrumb": [
      {
        "url": "/docs",
        "title": "Documentation"
      },
      {
        "url": "/docs/services",
        "title": "Services and Products"
      },
      {
        "url": "/docs/services/deep-index",
        "title": "Deep Index"
      },
      {
        "url": "/docs/services/deep-index/sync",
        "title": "Deep Index Sync"
      },
      {
        "url": "/docs/services/deep-index/sync/start",
        "title": "Getting started with Deep Index"
      }
    ]
  },
  {
    "text": "Below you can find the Kenshi Deep Index GraphQL schema.",
    "breadcrumb": [
      {
        "url": "/docs",
        "title": "Documentation"
      },
      {
        "url": "/docs/services",
        "title": "Services and Products"
      },
      {
        "url": "/docs/services/deep-index",
        "title": "Deep Index"
      },
      {
        "url": "/docs/services/deep-index/graphql",
        "title": "GraphQL for Deep Index"
      },
      {
        "url": "/docs/services/deep-index/graphql/schema",
        "title": "Deep Index GraphQL Schema"
      }
    ]
  },
  {
    "text": "This service costs $49.95 per month to run, plus $49.95 per million requests made to your\nwebhook endpoint. The price is paid in Kenshi tokens.\nIf you encounter any issues with payments, contact us at\nsupport@kenshi.io.\nTo get a grant on our services or to get a discount you can contact us at\ninquiries@kenshi.io.",
    "breadcrumb": [
      {
        "url": "/docs",
        "title": "Documentation"
      },
      {
        "url": "/docs/services",
        "title": "Services and Products"
      },
      {
        "url": "/docs/services/deep-index",
        "title": "Deep Index"
      },
      {
        "url": "/docs/services/deep-index/webhook",
        "title": "Reverse API for Deep Index"
      },
      {
        "url": "/docs/services/deep-index/webhook/pricing",
        "title": "R-API Pricing"
      }
    ]
  },
  {
    "text": "ERC-1363 token standard\nSolidity language\nHardhat,\nWaffle and\nChai for testing\nPrettier for formatting\nSlither and\nMythril for vulnerability scanning\nSvelte and SvelteKit\nVercek is used for deployments\nFontAwesome icons\nPrettier for formatting\nESLint for linting\nCadey Markup Language\nImplemented in Node.js\nEthers.js to interact with the blockchain\nAWS Lambda is used for deployments\nAWS SQS and EventBridge are used for scheduling\nImplemented in Node.js\nEthers.js to interact with the blockchain\nAWS Lambda is used for deployments\nAWS AppSync used for GraphQL\nMongoDB Atlas is used to store data\nMemcached used for caching",
    "breadcrumb": [
      {
        "url": "/docs",
        "title": "Documentation"
      },
      {
        "url": "/docs/tech",
        "title": "Tech Stack"
      }
    ]
  },
  {
    "text": "Kenshi has a generous approach for delivering randomness to your smart contracts.\nIn case of failure we retry twice within 2 minutes of the first try, if all fails we\nlog an entry for it in our db and queue it for a retry in 15 minutes, if that also\nfails we reschedule again for a retry in 1 hour, then 2 hours, 4 hours, 8 hours,\n24 hours and finally 48 hours until we give up.\nThat's a total of 10 retries. Failure can happen for variety of reasons, for example\nif you don't have enough Kenshi tokens stored in your smart contract for paying the\ndelivery fees or when the network is down. If the failure is from our side, we will\nresolve the issues as soon as possible and deliver the results out of schedule.\nA feature to notify contract owners of such failures is planned for the future.\nWe use multiple RPC endpoints for delivering your results. These endpoints are chosen\nbased on their uptime and latency. To check the status of the RPC endpoints or average\nVRF delivery times you can check our status page.",
    "breadcrumb": [
      {
        "url": "/docs",
        "title": "Documentation"
      },
      {
        "url": "/docs/services",
        "title": "Services and Products"
      },
      {
        "url": "/docs/services/oracle-network",
        "title": "Oracle Network"
      },
      {
        "url": "/docs/services/oracle-network/vrf",
        "title": "VRF Oracle"
      },
      {
        "url": "/docs/services/oracle-network/vrf/retry",
        "title": "VRF Retry Policy"
      }
    ]
  },
  {
    "text": "Kenshi's team of experts have years of experience in various development fields.\nBelow you can find a glimpse of what Kenshi team is capable of. You can send an\nemail to inquiries@kenshi.io to schedule a call\nand discuss your project with us.\nNFT smart contracts (ERC1155, ERC721), dynamic NFTs\nTokens (ERC20, ERC1363, etc)\nCustom smart contract development (Swaps, PegSwaps, Games, Marketplaces, Faucets, etc)\nCustom blockchain development\nHybrid & native mobile apps\nWebsites & dApps\nEmbedded & electronics\nServerless data flows & microservices",
    "breadcrumb": [
      {
        "url": "/docs",
        "title": "Documentation"
      },
      {
        "url": "/docs/services",
        "title": "Services and Products"
      },
      {
        "url": "/docs/services/development",
        "title": "Product Development"
      }
    ]
  },
  {
    "text": "The Kenshi Deep Index endpoint for GraphQL shares the same endpoint\nfor all blockchains and all event types:",
    "breadcrumb": [
      {
        "url": "/docs",
        "title": "Documentation"
      },
      {
        "url": "/docs/services",
        "title": "Services and Products"
      },
      {
        "url": "/docs/services/deep-index",
        "title": "Deep Index"
      },
      {
        "url": "/docs/services/deep-index/graphql",
        "title": "GraphQL for Deep Index"
      },
      {
        "url": "/docs/services/deep-index/graphql/endpoints",
        "title": "GraphQL Endpoints"
      }
    ]
  },
  {
    "text": "You can find resources related to the Unchained network on this page.\nGitHub\nTelegram\nForum\nIntroducing Unchained\nA Practical Guide to Unchained: Index Events and Token Prices on Any EVM Chain\nTODO.",
    "breadcrumb": [
      {
        "url": "/docs",
        "title": "Documentation"
      },
      {
        "url": "/docs/unchained",
        "title": "Unchained"
      },
      {
        "url": "/docs/unchained/resources",
        "title": "Resources"
      }
    ]
  },
  {
    "text": "Communication between the nodes is done using the Remote Procedure Call (RPC)\nprotocol. The RPC protocol is a simple protocol that allows a client to call a\nfunction on the network. The network will execute the function and return the\nresult to the client.\nUnchained implements a simple RPC protocol as follows:\nWhere:\nopcode  is a 1-byte field that specifies the operation to be performed.\ndata  is a variable-length field that contains the data for the operation.\nData is serialized using the MessagePack format.",
    "breadcrumb": [
      {
        "url": "/docs",
        "title": "Documentation"
      },
      {
        "url": "/docs/unchained",
        "title": "Unchained"
      },
      {
        "url": "/docs/unchained/specs",
        "title": "Specification"
      },
      {
        "url": "/docs/unchained/specs/rpc",
        "title": "RPC"
      }
    ]
  },
  {
    "text": "The MQL API endpoint costs $14.95 per million requests.  The price is paid in Kenshi tokens.\nIf you encounter any issues with payments, contact us at\nsupport@kenshi.io.\nTo get a grant on our services or to get a discount you can contact us at\ninquiries@kenshi.io.",
    "breadcrumb": [
      {
        "url": "/docs",
        "title": "Documentation"
      },
      {
        "url": "/docs/services",
        "title": "Services and Products"
      },
      {
        "url": "/docs/services/deep-index",
        "title": "Deep Index"
      },
      {
        "url": "/docs/services/deep-index/mql",
        "title": "MQL (MongoDB Query Language) for Deep Index"
      },
      {
        "url": "/docs/services/deep-index/mql/pricing",
        "title": "Deep Index MQL Pricing"
      }
    ]
  },
  {
    "text": "To integrate the Kenshi Reverse-API service into your ecosystem or workflow,\nyou need to expose an HTTP POST endpoint that is publicly available over the\ninternet. Once ready, you need to define an event listener task, so the Kenshi\ndispatcher can find relevant events for you and notify your endpoint whenever\nit finds them. Creating a task and registering your endpoint can be done using\nthe Kenshi dashboard.\nTo register a new Reverse-API endpoint you'll need to fill and submit the New Reverse-API form.\nYou can use the following list as a guide for each of the fields in this form.\nEndpoint : Your Reverse-API endpoint. This endpoint needs to be accessible over the internet.\nThis endpoint should accept post requests and return a \"200\" success code on successful receiving\nof the events. You can incorporate {event} into your URL, and the R-API will automatically\nsubstitute it with the name of each individual event sent to your designated endpoint.\nChain : The blockchain you are interested in. This is a part of the query that will run against\nthe Kenshi blockchain data clusters. This field cannot be modified later.\nStarting block : From which block should we start informing you of the events? You can choose a\nblock number in the past if you're looking for historical data. This field cannot be modified later.\nContract address : The source of the events you want to listen to. This is usually the\naddress of your smart contract, or the smart contract that emits the events you are looking for.\nContract ABI : Put ABI of the smart contract (from the  Contract address ) field here.\nYou can either put the entire ABI, or just include the ABI of the events you are interested in.\nThe ABI can be Human-Readable ABI or the ABI emitted by the Solidity compiler, in JSON format.\nDuration : For how many months should this task run?\nRequests : Amount of request credits you need for this endpoint. Each time a request is made to\nyour endpoint one request credit is charged.\nThe Kenshi event dispatcher for Reverse-API caches all events in a \"memcached\"\ninstance to prevent sending duplicate events to your endpoints. The TTL of the cache is 15 minutes.\nHowever, you should make sure your endpoint knows how to handle duplicated calls.",
    "breadcrumb": [
      {
        "url": "/docs",
        "title": "Documentation"
      },
      {
        "url": "/docs/services",
        "title": "Services and Products"
      },
      {
        "url": "/docs/services/deep-index",
        "title": "Deep Index"
      },
      {
        "url": "/docs/services/deep-index/webhook",
        "title": "Reverse API for Deep Index"
      },
      {
        "url": "/docs/services/deep-index/webhook/start",
        "title": "Getting Started with R-API"
      }
    ]
  },
  {
    "text": "We estimate how much gas is required to deliver randomness to your smart contract, add 15% to it,\nconvert it to Kenshi and then charge that amount from your VRF subscription.\nVRF subscriptions can be made on the Kenshi dashboard. All payments\nfor the VRF fees are processed off-chain and therefore are gas-free. This makes the\nKenshi VRF cheaper compared to the rest.\nMake sure you have enough Kenshi tokens in your VRF subscription for paying the\nVRF fees.\nThe VRF service is free of charge on testnets.",
    "breadcrumb": [
      {
        "url": "/docs",
        "title": "Documentation"
      },
      {
        "url": "/docs/services",
        "title": "Services and Products"
      },
      {
        "url": "/docs/services/oracle-network",
        "title": "Oracle Network"
      },
      {
        "url": "/docs/services/oracle-network/vrf",
        "title": "VRF Oracle"
      },
      {
        "url": "/docs/services/oracle-network/vrf/pricing",
        "title": "VRF Pricing"
      }
    ]
  },
  {
    "text": "The GraphQL API endpoint costs $14.95 per million requests. The price is paid in Kenshi tokens.\nIf you encounter any issues with payments, contact us at\nsupport@kenshi.io.\nTo get a grant on our services or to get a discount you can contact us at\ninquiries@kenshi.io.",
    "breadcrumb": [
      {
        "url": "/docs",
        "title": "Documentation"
      },
      {
        "url": "/docs/services",
        "title": "Services and Products"
      },
      {
        "url": "/docs/services/deep-index",
        "title": "Deep Index"
      },
      {
        "url": "/docs/services/deep-index/graphql",
        "title": "GraphQL for Deep Index"
      },
      {
        "url": "/docs/services/deep-index/graphql/pricing",
        "title": "Deep Index GraphQL Pricing"
      }
    ]
  },
  {
    "text": "The Kenshi token follows the regulatory definition of utility tokens in\nSwitzerland:\nFINMA defines utility tokens as tokens intended to provide access digitally\nto an application or service by means of a blockchain-based infrastructure.\nArbiScan\nUniSwap Pool\nBuy on UniSwap\nHacken Audit\nContract Source Code\nThe Kenshi ERC20 token contract address on Arbitrum is:\nThe Kenshi utility token is closely tied to the Kenshi ecosystem. Some of the\nutilities of this token are:\nProducts & Services : The token can be used to unlock access to the\nproducts and services provided by Kenshi.\nVoting : The token can be used to vote on community matters, or the\ndirection of the Unchained network. See the Kenshi Engagement Protocol.\nUnchained Nodes : The Unchained protocol implements a\nLiquid Proof of Stake\nconsensus mechanism. Unchained validators stake KNS tokens to improve the\nsecurity of the Unchained network.\nUnchained Consumers :  Consumers use KNS to access validated data stored\non the Unchained network. Validators receive these tokens as a reward for running\nan active node. This is the equivalent of using ETH on the Ethereum network for gas.\nThe Kenshi v3 token has a total supply of 1B tokens. The majority of the tokens\nare offered to the public on UniSwap. You can see an overview of the token\ndistribution in the chart below.\nUsers : Includes tokens currently held by the users, and tokens in the\nUniSwap liquidity pool.\nTreasury : Includes tokens accumulated by Kenshi due to direct or\nindirect product sales.\nReserve : Is the buy back address.\nStaking Rewards : Is the amount of tokens allocated as staking rewards.\nCurrently 10M of these tokens are stored in the Kenshi staking contract.\nPartners & Ecosystem : Reserved for future partnerships; for example,\nCEX or DEX listings, new chains, etc.\nGrants, Academy & Incentives : Reserved for projects building on Kenshi,\nacademy rewards, and community rewards.",
    "breadcrumb": [
      {
        "url": "/docs",
        "title": "Documentation"
      },
      {
        "url": "/docs/token",
        "title": "The Kenshi token"
      },
      {
        "url": "/docs/token/tokenomics",
        "title": "Tokenomics"
      }
    ]
  },
  {
    "text": "Custom Oracles hosted on Kenshi Oracle Network cost a fixed monthly fee depending on the selected\npricing plan, plus $1 for each 5000 requests processed by the oracle.\nThe Oracle Network guarantees a sub-second delay for sourcing events from the blockchain.\nThe maximum time for processing each request (getting a response from your endpoint and\nsending it to the blockchain) is 3 minutes.\nThe Oracle Network's event dispatcher retries delivery on failure. Retries happen three\ntimes immediately after a failure, and a total of 7 times in the next 48 hours.",
    "breadcrumb": [
      {
        "url": "/docs",
        "title": "Documentation"
      },
      {
        "url": "/docs/services",
        "title": "Services and Products"
      },
      {
        "url": "/docs/services/oracle-network",
        "title": "Oracle Network"
      },
      {
        "url": "/docs/services/oracle-network/custom",
        "title": "Custom Oracles"
      },
      {
        "url": "/docs/services/oracle-network/custom/price",
        "title": "Price"
      }
    ]
  },
  {
    "text": "On this page, you'll find detailed information about our ongoing projects,\ncompleted achievements, and future plans. Explore each section to stay updated\nand informed about our progress and direction.\n✅  Token : ERC20 token released natively on Arbitrum One.\n✅  Website : Website, and the Kenshi Dashboard are live.\n✅  Forum : Kenshi forum, an open crypto hub, is publicly available.\n✅  Community : Active communities on Telegram, Discord, Twitter.\n✅  Community Engagement : Kenshi Engagement Protocol is functional.\nZealy.io is used for community-centric collaborations.\n✅  Staking : Kenshi staking program is publicly available to all KNS users.\n✅  DEX : Kenshi token is listed on UniSwap.\n☑️  CEX : Kenshi token is not listed on a CEX. The target for a CEX listing\nis a +$25M market cap.\n✅  Deep Index : Kenshi Deep Index, a serverless framework for indexing\nblockchain events is released on 8 EVM chains.\n✅  R-API : Kenshi R-API, a push notification service for receiving and\nprocessing blockchain events is live and on 8 EVM chains.\n✅  IoT SDK : Kenshi IoT SDK, a suite of libraries to enable processing of\nblockchain events on embedded devices is released for Arduino, ESP32, and Zephyr.\nThe IoT SDK is available on +200 development boards for quick prototyping.\n✅  Oracle Network : Kenshi Oracle Network, a serverless, asynchronous,\nfault-tolerant network for creating custom oracles is live on 8 EVM blockchains.\n⏳  IoT Boards / HSM : Kenshi is building embedded devices that are able to\nsecurely connect to the blockchain, manage crypto-assets, manage secrets, make\nsecure API requests, and more.\n⏳  Unchained : Kenshi Unchained is peer-to-peer decentralized network for\nvalidating data. Unchained is the future of Kenshi, aiming to decentralize all of\nthe Kenshi products mentioned above.\nYou can find detailed roadmap of our ongoing projects in this section.\nUnchained is a peer-to-peer, decentralized network for data validation.\nYou can find our Unchained progress here:\n✅  Federated Network : The Unchained testnet is available. The\nUnchained client is able to auto-recover and connect to peers.\n✅  Data Validation : The underlying decentralized protocol for\nvalidating pieces of data is in place. BLS signature aggregation is\nused by peers to sign data.\n✅  Persistence : The validated data is persisted in PostgreSQL.\n⏳  Smart Contracts : Unchained uses a Liquid Proof of Stake consensus\nmechanism. We are working on smart contracts to allow users to stake their\nKNS tokens for the Unchained network.\n⏳  RPC : We need an interface for consumers to be able to query\nvalidated data on the Unchained network.\n☑️  Plugins : Plugins for the different Unchained use cases still\nneed to be developed.\n☑️  Documentation : Unchained isn't fully documented yet.\n☑️  Explorer : We need an explorer and status page for Unchained.\nHSMs can be used to manage custody of crypto assets. For example,\nby banks or exchanges.\nThey can be used as programmable wallets by DeFi projects, or to\nmake secure API requests.\nThe Kenshi HSM can be used as a more secure alternative to existing\nsecret managers, such as HashiCorp Vault.\nThese devices can also be used for decentralized oracles, data\ncollection networks, supply chain management, and plenty of other use\ncases.\nYou can find our HSM progress here:\n✅  Prototype : We have made a prototype HSM, including the hardware,\nand several firmwares.\n⏳  Open Hardware : We are investigating a Bring-Your-Own-Hardware\noption where users can benefit from the Kenshi HSM capabilities on hardware\nthat is easily sourceable on the market.\n⏳  Partnerships : We are in contact with Swiss semiconductor and\nsecure hardware manufacturers.\n☑️  Firmwares : Firmwares for different use cases, and a GUI app for\nmanaging the software on the HSM devices are required before HSM release.\n☑️  Certification : The custom-made electronics need to be certified.",
    "breadcrumb": [
      {
        "url": "/docs",
        "title": "Documentation"
      },
      {
        "url": "/docs/roadmap",
        "title": "Roadmap"
      }
    ]
  },
  {
    "text": "On this page you can find examples for Node.js, and Python.\nUsing Express\nThis example requires Node.js v14.8+ and the express npm package installed.\nThis example is also available on GitHub.\nUsing Flask\nThis example requires the flask Python package installed.\nThis example is also available on GitHub.",
    "breadcrumb": [
      {
        "url": "/docs",
        "title": "Documentation"
      },
      {
        "url": "/docs/services",
        "title": "Services and Products"
      },
      {
        "url": "/docs/services/deep-index",
        "title": "Deep Index"
      },
      {
        "url": "/docs/services/deep-index/webhook",
        "title": "Reverse API for Deep Index"
      },
      {
        "url": "/docs/services/deep-index/webhook/examples",
        "title": "R-API Examples"
      }
    ]
  },
  {
    "text": "Removed the Deep Index Sync Task hard requirement.\nAdded \"requests\" option: pricing is now based on how many requests are made\nto the user's endpoint. This reduces the price significantly for smaller workloads.\nReverse-API launch.",
    "breadcrumb": [
      {
        "url": "/docs",
        "title": "Documentation"
      },
      {
        "url": "/docs/services",
        "title": "Services and Products"
      },
      {
        "url": "/docs/services/deep-index",
        "title": "Deep Index"
      },
      {
        "url": "/docs/services/deep-index/webhook",
        "title": "Reverse API for Deep Index"
      },
      {
        "url": "/docs/services/deep-index/webhook/changes",
        "title": "R-API Change Log"
      }
    ]
  },
  {
    "text": "The Kenshi token is a utility token that grants users access to the Kenshi\necosystem. The token implements the ERC20 interface, is natively deployed on the\nArbitrum One blockchain, and has a 10/10 perfect audit score by Hacken.\nSee the Tokenomics page for more information.\nTokenomics",
    "breadcrumb": [
      {
        "url": "/docs",
        "title": "Documentation"
      },
      {
        "url": "/docs/token",
        "title": "The Kenshi token"
      }
    ]
  },
  {
    "text": "Once you have configured your node, you can run it with one of the following\ncommands.\nRun in the directory where your installation is located:\nTo use the default locations for config file, secrets file, and the context DB,\nrun this command:\nTo specify the path to your config file, secrets file, and the context DB, run\nthis command:\nYou can run the following command to see all the available options:",
    "breadcrumb": [
      {
        "url": "/docs",
        "title": "Documentation"
      },
      {
        "url": "/docs/unchained",
        "title": "Unchained"
      },
      {
        "url": "/docs/unchained/nodes",
        "title": "Running a Node"
      },
      {
        "url": "/docs/unchained/nodes/run",
        "title": "Running the Unchained Client"
      }
    ]
  },
  {
    "text": "Instead of querying for new data on a specific interval, with the Kenshi Reverse\nAPI you can just subscribe to the blockchain events you are interested in and let\nour dispatcher notify your HTTP endpoint with the data you requested.\nIntroduction to R-API\nGetting Started with R-API\nR-API Examples\nR-API Schema\nIntegrations\nR-API Pricing\nR-API Change Log",
    "breadcrumb": [
      {
        "url": "/docs",
        "title": "Documentation"
      },
      {
        "url": "/docs/services",
        "title": "Services and Products"
      },
      {
        "url": "/docs/services/deep-index",
        "title": "Deep Index"
      },
      {
        "url": "/docs/services/deep-index/webhook",
        "title": "Reverse API for Deep Index"
      }
    ]
  },
  {
    "text": "To request a verifiable random number, your smart contract should inherit from this\nlibrary. To see an example of doing that refer to our\nD20 example. The VRF Consumer\nprovides the following functions:\nsetupVRF : This function is overloaded and accepts either one or three arguments:\nThe VRF coordinator address, a boolean value indicating if the received VRF results\nshould be verified on the chain, and a boolean value indicating if \"randomnessFulfilled\"\nevents should be emitted. The two latter arguments are optional and default to \"false\".\nNotes: This function automatically retrieves the VRF Utils address from the VRF coordinator\nand sets it up for you.\nsetVRFCoordinatorAddr : Used to set the VRF coordinator address for requesting randomness.\nThis function does NOT automatically setup VRF Utils.\nsetVRFUtilsAddr : Used to set the VRF Utils address. The VRF Utils contract is used to verify\nrandomness on the chain. This library is also used to derive the beta value and generate a random\nnumber from the VRF proof.\nsetVRFShouldVerify : Sets if the randomness should be verified on the chain. This will increase\nthe gas used significantly.\nsetVRFIsSilent : Sets if the \"randomnessFulfilled\" should be emitted. Turn off for gas saving.\nrequestRandomness : Calls the \"requestRandomness\" method of the VRF coordinator. You should call\nthis method each time you need a random number. Returns the \"requestId\", you can store this value\nto map VRF results with a user request.\nonRandomnessReady : This function is called by the VRF coordinator when the VRF results are ready.\nfulfillRandomness : An abstract function that does nothing. This is called by the \"onRandomnessReady\"\nfunction when a VRF result is received and verified. You need to re-implement this in your smart contract.\nAnything you need to do with the randomness you requested should be implemented here.\nFor function signatures check the VRF consumer repository.\nThe VRF Utils Solidity library is released in source form together with a JavaScript VRF implementation\nlibrary. This library is deployed to all chains and is made available free of charge to anyone who finds\na use for it. This library is used by the Kenshi consumer for calculating the VRF beta which is used to\ngenerate randomness on chain. It is also used to verify the VRF results on chain.\nRefer to the\nVRFUtils.sol file\non Github to check the available functions. Read the\nECVRF draft to\nlearn more about each function.",
    "breadcrumb": [
      {
        "url": "/docs",
        "title": "Documentation"
      },
      {
        "url": "/docs/services",
        "title": "Services and Products"
      },
      {
        "url": "/docs/services/oracle-network",
        "title": "Oracle Network"
      },
      {
        "url": "/docs/services/oracle-network/vrf",
        "title": "VRF Oracle"
      },
      {
        "url": "/docs/services/oracle-network/vrf/api",
        "title": "VRF API Interface"
      }
    ]
  },
  {
    "text": "Unchained system addresses are generated by deriving from the public key, which\nis itself derived from the client's BLS private key, specifically within the G2\ncurve context. This setup is optimized for shorter signatures, with the trade-off\nof utilizing longer public keys.\nAfter deriving the public key from the private key, the address is generated by\nfirst calculating the Shake256 hash of the public key, then taking the first 20\nbytes of the hash, and finally encoding the result in Base32.\nTwo checksum bytes are appended to the address, which is calculated by taking\nthe first 2 bytes of the Shake256 hash of the address, calculating the modulo 32\nof each byte, and then encoding the result in Base32.\nThe final address format is as follows:\nblock-beta\ncolumns 4\naddr[\"FCB64Q7Y72N123NED23N0C0TEHHXZFSE\"]:3 sum[\"8B\"]:1\nspace:4\naddrb[\"Address\"]:3 sumb[\"Checksum\"]:1\naddr --> addrb\nsum --> sumb\nThis address format is used for the Unchained system and is the default address\nformat for the client. The address is used to identify the client in the system\nand is used for various purposes, such as signing transactions and verifying\nsignatures.\nThe address is case-insensitive, meaning that the same address can be written\nin either uppercase or lowercase. The checksum is used to ensure that the address\nis valid and has not been tampered with.\nUnchained uses a custom Base32 encoding scheme for encoding public keys into addresses.\nThe custom Base32 encoding scheme is designed to be more human-readable and easier to\ntranscribe than the standard Base32 encoding scheme.\nThe custom Base32 encoding scheme uses the following character set:\nAs you can see, the custom Base32 encoding scheme excludes the letters \"I\", \"L\", and \"O\"\nto avoid confusion with the numbers \"1\", and \"0\". It also drops the letter \"W\" to avoid\nconfusion with the letters \"U\" (double-U in English), and \"V\" (double-V in French).",
    "breadcrumb": [
      {
        "url": "/docs",
        "title": "Documentation"
      },
      {
        "url": "/docs/unchained",
        "title": "Unchained"
      },
      {
        "url": "/docs/unchained/specs",
        "title": "Specification"
      },
      {
        "url": "/docs/unchained/specs/address",
        "title": "Unchained Address"
      }
    ]
  },
  {
    "text": "The following Solidity code implements a D20 smart contract using\nthe Kenshi VRF service.\nThis contract is deployed to and is testable on all Kenshi supported blockchains,\nyou can find the contract address on the next section.\nThe D20 is a 20-sided die. The d20 System is a role-playing game system published in 2000 by\nWizards of the Coast, originally developed for the third edition of Dungeons & Dragons.\nThe system is named after the 20-sided dice which are central to the core mechanics of many\nactions in the game. [Wikipedia]\nThis example is also available on GitHub.\nAfter deploying the above example, you need to call the ``setVRFConfig`` function with\nappropriate parameters depending on the chain your contract is deployed to. This\ninformation can be found in the next section.\nExposing a public function for setting the VRF config is not required, you can just\ncall the \"setupVRF\" function inside your contract constructor. However, we highly\nrecommend exposing such a functionality to make your VRF version upgradable.",
    "breadcrumb": [
      {
        "url": "/docs",
        "title": "Documentation"
      },
      {
        "url": "/docs/services",
        "title": "Services and Products"
      },
      {
        "url": "/docs/services/oracle-network",
        "title": "Oracle Network"
      },
      {
        "url": "/docs/services/oracle-network/vrf",
        "title": "VRF Oracle"
      },
      {
        "url": "/docs/services/oracle-network/vrf/example",
        "title": "VRF Examples"
      }
    ]
  },
  {
    "text": "Below you can find the Kenshi Deep Index MQL schemas.\nAvailable blockchains are:",
    "breadcrumb": [
      {
        "url": "/docs",
        "title": "Documentation"
      },
      {
        "url": "/docs/services",
        "title": "Services and Products"
      },
      {
        "url": "/docs/services/deep-index",
        "title": "Deep Index"
      },
      {
        "url": "/docs/services/deep-index/mql",
        "title": "MQL (MongoDB Query Language) for Deep Index"
      },
      {
        "url": "/docs/services/deep-index/mql/schema",
        "title": "Deep Index MQL Schema"
      }
    ]
  },
  {
    "text": "The Kenshi IoT SDK supports Arduino and ESP32-compatible boards through\nthe Arduino IDE and ecosystem. All network-enabled boards supported by\nZephyr\nare supported by this SDK. Check the official Kenshi Deep Index MQL/GraphQL\ndocumentation for Linux development boards.\nAll boards based on the ESP32 SoC and programmable by Arduino IDE, including:\nESP32 Devkits\nAdafruit HUZZAH32\nSparkFun ESP32 Thing Plus\nWemos LOLIN D32\nSeeed Studio XIAO ESP32C3\nDFRobot FireBeetle ESP32\nand others.\nAny board with internet connectivity supported by one of the libraries below:\nWiFiNINA:\nArduino MKR WiFi 1010\nArduino MKR VIDOR 4000\nArduino UNO WiFi Rev.2\nArduino Nano 33 IoT\nArduino Nano RP2040 Connect\nWiFi101:\nArduino MKR1000 WiFi\nArduino/Genuino Wifi Shield 101\nEthernet:\nArduino Ethernet Board\nArduino Ethernet Shield\nMKRGSM:\nArduino MKR GSM 1400\nMKRNB:\nArduino MKR NB 1500\nWiFi:\nArduino WiFi Shield\nGSM:\nArduino GSM Shield\nThe following boards are supported using the Zephyr RTOS:\nElkhart Lake CRB\nX86 Emulation (QEMU)\nRaptor Lake CRB\nUP Squared\n96Boards Aerocore2\n96Boards Avenger96\n96Boards Carbon\n96Boards Meerkat96\nActinius Icarus\nActinius Icarus Bee\nActinius Icarus SoM\nArduino Nano 33 IOT\nSAM E54 Xplained Pro Evaluation Kit\nST B-G474E-DPOW1 Discovery\nST B_L4S5I_IOT01A Discovery kit\nST B_U585I_IOT02A Discovery kit\nLaird Connectivity BL5340 DVK\nBlack STM32 F407VE Development Board\nBlack STM32 F407ZG Pro Development Board\nCC3220SF LaunchXL\nCC3235SF LaunchXL\nnRF9160 Feather\nNXP i.MX 7 Computer on Module - Colibri iMX7\nPSoC6 WiFi-BT Pioneer Kit\nIntel® Cyclone® V SoC Development Kit\nST Disco L475 IOT01 (B-L475E-IOT01A)\nDragino NBSN95 NB-IoT Sensor Node\nWGM160P Starter Kit\nEFM32 Giant Gecko GG11 Starter Kit\nEFR32 Radio Boards\nNXP FRDM-K64F\nGigaDevice GD32E507Z-EVAL\nGigaDevice GD32F450I-EVAL\nGigaDevice GD32F450Z-EVAL\nGigaDevice GD32F470I-EVAL\nGoogle Kukui EC\nHexiwear\nSEGGER IP Switch Board\nLegend\nLaird Connectivity Sentrius™ MG100 Gateway\nNXP MIMX8MM EVK\nNXP MIMX8MP EVK\nNXP MIMX8MQ EVK\nNXP MIMXRT1020-EVK\nNXP MIMXRT1024-EVK\nNXP MIMXRT1050-EVK\nNXP MIMXRT1060-EVK\nNXP MIMXRT1064-EVK\nNXP MIMXRT1160-EVK\nNXP MIMXRT1170-EVK\nARM MPS2+ AN521\nARM MPS3 AN547\nnRF52840 MDK USB Dongle\nnRF5340 DK\nnRF9160 INNBLUE21\nnRF9160 INNBLUE22\nnRF9160 DK\nST Nucleo F030R8\nST Nucleo F031K6\nST Nucleo F070RB\nST Nucleo F091RC\nST Nucleo F103RB\nST Nucleo F207ZG\nST Nucleo F334R8\nST Nucleo F412ZG\nST Nucleo F429ZI\nST Nucleo F746ZG\nST Nucleo F756ZG\nST Nucleo F767ZI\nST Nucleo G031K8\nST Nucleo G071RB\nST Nucleo G0B1RE\nST Nucleo H723ZG\nST Nucleo H743ZI\nST Nucleo H745ZI-Q\nST Nucleo H753ZI\nST Nucleo L011K4\nST Nucleo L031K6\nST Nucleo L053R8\nST Nucleo L073RZ\nST Nucleo L152RE\nST Nucleo L476RG\nST Nucleo L496ZG\nST Nucleo L4A6ZG\nST Nucleo L4R5ZI\nNUVOTON NUMAKER PFM M487\nParticle Argon\nParticle Boron\nLaird Connectivity Pinnacle 100 DVK\nARM Cortex-M3 Emulation (QEMU)\nRAK5010\nNXP RDDRONE-FMUK66\nreel board\nSAM4E Xplained Pro\nSAM E70(B) Xplained\nSAM V71(B) Xplained Ultra\nST SensorTile.box\nnRF9160 Thing Plus\nST STM3210C Evaluation\nST STM32373C Evaluation\nST STM32F0 Discovery\nSTM32F103 Mini\nSECO JUNO SBC-D23 (STM32F302)\nST STM32F429I Discovery\nST STM32F469I Discovery\nST STM32F4 Discovery\nST STM32F746G Discovery\nST STM32F7508-DK Discovery Kit\nST STM32F769I Discovery\nST STM32G071B Discovery\nST STM32G081B Evaluation\nST STM32H735G Discovery\nST STM32H747I Discovery\nST STM32L1 Discovery\nST STM32L476G Discovery\nST STM32L496G Discovery\nST STM32L562E-DK Discovery\nST STM32VL Discovery\nPJRC TEENSY 4\nNXP TWR-KV58F220M\nUDOO Neo Full\nARM V2M Musca-S1\nWaRP7 - Next Generation IoT and Wearable Development Platform\nIntel Agilex SoC Development Kit\nNXP i.MX8MM EVK (Cortex-A53)\nNXP i.MX8MN EVK (Cortex-A53)\nNXP i.MX8MP EVK (Cortex-A53)\nNXP i.MX93 EVK (Cortex-A55)\nNXP LS1046A RDB\nARMv8 Xen Virtual Machine Example\nDesignWare(R) ARC(R) HS Development Kit\nARCv2 & ARCv3 Emulation (QEMU)\nAltera MAX10\nAltera Nios-II Emulation (QEMU)\nESP32\nESP32-ETHERNET-KIT\nESP32-NET\nESP32-S2 Franzininho\nESP32-S2\nESP-WROVER-KIT\nHeltec WiFi LoRa 32 (V2)\nZephyr Audio DSP Development on Chromebooks\nM5StickC PLUS\nODROID-GO\nOlimex ESP32-EVB\nNative POSIX execution (native_posix)\nAndes ADP-XC7K AE350\nESP32-C3\nICE-V Wireless\nOpenISA VEGAboard\nM5Stack STAMP-C3\nXIAO ESP32C3\nGeneric LEON3\nAdafruit WINC1500 Wifi Shield\nARCELI W5500 ETH\nAtmel AT86RF2XX Transceivers\nESP-8266 Modules\nInventek es-WIFI Shield\nPHYTEC link board ETH\nMicrochip MCP2515 CAN bus shields\nMikroElektronika ETH Click\nMikroElektronika WIFI and BLE Shield\nX-NUCLEO-IDB05A1: BLE expansion board\nSee more on the Zephyr documentation.\nAll boards running a variant of Linux, BSD or Windows are supported:\nRaspberry Pi\nNvidia Jetson\nASUS Tinker Board\nBeagleBoard/BeagleBone\nHardkernel/ODRIOD\nPine64\nBanana Pi\nOrange Pi\nRock Pi\nLattePanda\nLibre Computer/Le Potato",
    "breadcrumb": [
      {
        "url": "/docs",
        "title": "Documentation"
      },
      {
        "url": "/docs/services",
        "title": "Services and Products"
      },
      {
        "url": "/docs/services/iot",
        "title": "Kenshi IoT SDK"
      },
      {
        "url": "/docs/services/iot/devices",
        "title": "Supported devices"
      }
    ]
  },
  {
    "text": "To work with the MQL endpoint, you need to serialize your MQL query together\nwith your API key, API key owner and the desired blockchain in a JSON package.\nThen you can make an HTTP POST request to the Kenshi Deep Index endpoint\nfor MQL. The endpoint address and examples for making MQL requests\ncan be found in the next chapters.\nThe schema for returned data types, as well as the schema for making requests\nto the MQL endpoint, are also provided. The provided schema can be used in\nlanguages such as Go where an interface is required for unpacking the received\nMQL data.\nTo create an API key for querying the MQL endpoint, you can head over to\nthe Kenshi dashboard, connect your wallet,\nfill and submit the \"New GraphQL + MQL API Key\" form.\nTo fill and submit the new MQL API key form you can refer to the following manual:\nAPI Key : You can use the auto-generated API key, and auto-generate a new one by pressing\nthe small \"refresh\" button on the field, or by generating and providing your own. The API\nkeys are scoped, they're only valid if combined with the address of their owner. In other\nwords, you'll need to provide your public address as well as this API key for making any\nrequests to the MQL endpoint.\nRequests : The number of requests you're expecting to have. This amount does not expire\nby the passing of time, but every successful or unsuccessful call counts as one usage and\ndecreases the remaining possible \"requests\" by one.\nQuery limits : You can add a limit to your API keys. For example, you can define an event\ntype or a contract address. The API endpoint then is going to throw an error if a query is\nmade using this API key that doesn't match the query limits. This field is optional.\nFor Query limits, you should use checksummed hex values for argument values. Use lowercase\nvalues anywhere else.\nThe MQL endpoint can return a maximum of 1024 records at a time. The maximum processing time for\neach request is 5 seconds, and the maximum size of returned data is 1MB.",
    "breadcrumb": [
      {
        "url": "/docs",
        "title": "Documentation"
      },
      {
        "url": "/docs/services",
        "title": "Services and Products"
      },
      {
        "url": "/docs/services/deep-index",
        "title": "Deep Index"
      },
      {
        "url": "/docs/services/deep-index/mql",
        "title": "MQL (MongoDB Query Language) for Deep Index"
      },
      {
        "url": "/docs/services/deep-index/mql/start",
        "title": "Getting started with Deep Index"
      }
    ]
  },
  {
    "text": "Getting started with the Kenshi Oracle Network is easy. The logic part of your oracle can\nbe developed in the language of your choice, it only needs to implement the Custom Oracle Protocol.\nYou can host the logic part on any serverless (or serverful) solutions such as\nAWS Lambda\nVercel\nCloudflare Workers\nMicrosoft Azure Functions\nGoogle Cloud Functions\nNetlify Functions\nand others.\nOnce you're ready with the logic side of your oracle, you can head to the Kenshi Dashboard\nand click on the \"Custom Oracle\" tile. Follow the instructions on the \"New Oracle\" form to deploy your\ncustom oracle.\nOnce you deploy your oracle, you can see the address of the gas wallet associated with your oracle on the\nCustom Oracle Dashboard. You must supply enough gas to this address\nfor oracle network to fulfill your oracle's requests.\nOnce you transfer gas to the associated address, the gas belongs to Kenshi and its Oracle Network\nand is not refundable. Make sure you don't supply more gas than your oracle requires.\nThe Kenshi Nonce Manager is an Ethereum compatible nonce management solution by Kenshi for sending\ntransactions in parallel. It is crucial to understand how the Kenshi\nNonce Manager\nworks. For each request to your smart contract, the Kenshi Nonce Manager:\nAssigns a nonce, keeping track of the last used nonce in the database,\nEstimates the gas required to fulfil the request,\nUses the gas estimate and the assigned nonce to sign and send a transaction to fulfil the request,\nIncreases the gas and resends the transaction if the transaction doesn't get approved within a minute,\nBurns the nonce by re-using it in a zero-eth transfer transaction if transaction isn't fulfilled after\nthree retries,\nRe-schedules the request fulfilment for later if the assigned nonce is burned.\nIf there are gaps in the nonce or there are too many canceled transactions due to errors such as network\ncongestion or RPC node failures, the Nonce Manager will eventually burn the entire gas in the oracle's wallet.\nThe Kenshi Nonce Manager tries to prevent such scenarios and keep the nonces in order. However, Kenshi cannot\nguarantee the procedure is error-free.\nTo prevent catastrophic events, Kenshi allows adjusting the maximum number of unresolved requests sent to the\nblockchain from your oracle. When choosing a number for this parameter, you should consider the risks involved\nin nonce management, as well as the needs of your application.",
    "breadcrumb": [
      {
        "url": "/docs",
        "title": "Documentation"
      },
      {
        "url": "/docs/services",
        "title": "Services and Products"
      },
      {
        "url": "/docs/services/oracle-network",
        "title": "Oracle Network"
      },
      {
        "url": "/docs/services/oracle-network/custom",
        "title": "Custom Oracles"
      },
      {
        "url": "/docs/services/oracle-network/custom/start",
        "title": "Getting started"
      }
    ]
  },
  {
    "text": "On this page you can find examples for Node.js, Python and Go languages.\nUsing AxiosUsing Fetch\nThis example requires Node.js v14.8+ and the axios npm package installed.\nThis example is also available on GitHub.\nUsing Requests\nThis example requires the requests Python package installed.\nThis example is also available on GitHub.\nUsing net/http\nThis example uses the built-in net/http module.\nThis example is also available on GitHub.",
    "breadcrumb": [
      {
        "url": "/docs",
        "title": "Documentation"
      },
      {
        "url": "/docs/services",
        "title": "Services and Products"
      },
      {
        "url": "/docs/services/deep-index",
        "title": "Deep Index"
      },
      {
        "url": "/docs/services/deep-index/mql",
        "title": "MQL (MongoDB Query Language) for Deep Index"
      },
      {
        "url": "/docs/services/deep-index/mql/examples",
        "title": "MQL Examples"
      }
    ]
  },
  {
    "text": "The goal of Kenshi Oracle Network is to enable developers to build their oracles using\nthe technologies they know, while taking care of everything else from event sourcing to\ndata delivery.\nTo allow maximum flexibility, we require you to create the logic part of your oracle and\nhost it on your own infrastructure. The logic part needs to implement the following:\nPOST:  HTTP endpoint accepting POST requests.\nRequest Body:  Events are sent to this endpoint for processing. The events are\nin JSON format.\nResponse Code:  You must return a HTTP success code, otherwise the Kenshi event\ndispatcher will attempt retries.\nResponse Body:  You must respond with the instructions on how to process the event\nand what data should be sent to your smart contract on the blockchain. Response body\nshould be JSON-formatted.\nYou are free to use the technology of your choice to implement the above protocol.\n\",\"description\":\"Arguments to pass to the selected method. Each argument needs to match\\n                the corresponding argument on the selected method and be parsable by\\n                the ethers.js library\"},{\"id\":2,\"field\":\"maxGas\",\"type\":\"Number | Decimal String | Hex String\",\"description\":\"Maximum amount of gas (in wei) you're willing to spend on this request\"},{\"id\":3,\"field\":\"abort\",\"type\":\"Boolean | Null | Undefined\",\"description\":\"Send true to abort delivering and ignore this event\"}]} />\nNumbers can be returned as a JSON number type, a hex string, or a decimal string.\nYou can find the ethers.js documentation here.",
    "breadcrumb": [
      {
        "url": "/docs",
        "title": "Documentation"
      },
      {
        "url": "/docs/services",
        "title": "Services and Products"
      },
      {
        "url": "/docs/services/oracle-network",
        "title": "Oracle Network"
      },
      {
        "url": "/docs/services/oracle-network/custom",
        "title": "Custom Oracles"
      },
      {
        "url": "/docs/services/oracle-network/custom/protocol",
        "title": "Custom Oracle Protocol"
      }
    ]
  },
  {
    "text": "To work with the GraphQL endpoint, you need to use a GraphQL library,\nor directly make an HTTP POST request to the Kenshi Deep Index endpoint\nfor GraphQL. The endpoint address and examples for making GraphQL requests\ncan be found on the next chapters.\nThe schema for returned data types, as well as the schema for making requests\nto the GraphQL endpoint are also provided. The provided schema can be used in\nlanguages such as Go where an interface is required for unpacking the received\nGraphQL data.\nTo create an API key for querying the GraphQL endpoint, you can head over to\nthe Kenshi dashboard, connect your wallet,\nfill out and submit the \"New GraphQL + MQL API Key\" form.\nTo fill and submit the new GraphQL API key form you can refer to the following manual:\nAPI Key  You can use the auto-generated API key, and auto-generate a new one by pressing\nthe small \"refresh\" button on the field, or by generating and providing your own. The API\nkeys are scoped, they're only valid if combined with the address of their owner, in other\nwords you'll need to provide your public address as well as this API key for making requests.\nRequests  The number of requests you're expecting to have. This amount does not expire\nby the passing of time, but every successful or unsuccessful call counts as one usage and\ndecreases the remaining possible \"requests\" by one.\nQuery limits  You can add a limit to your API keys. For example, you can define an event\ntype or a contract address. The API endpoint then is going to throw an error if a query is\nmade using this API key that doesn't match the query limits. This field is optional.\nHex values should not be checksummed. All values for query limits should be in lowercase.\nThe GraphQL endpoint can return a maximum of 1024 records at a time. The maximum processing time for\neach request is 5 seconds, and the maximum size of returned data is 1MB.",
    "breadcrumb": [
      {
        "url": "/docs",
        "title": "Documentation"
      },
      {
        "url": "/docs/services",
        "title": "Services and Products"
      },
      {
        "url": "/docs/services/deep-index",
        "title": "Deep Index"
      },
      {
        "url": "/docs/services/deep-index/graphql",
        "title": "GraphQL for Deep Index"
      },
      {
        "url": "/docs/services/deep-index/graphql/start",
        "title": "Getting Started with GraphQL"
      }
    ]
  },
  {
    "text": "Pricing for the sync service depends on the storage and frequency chosen while creating\nthe task. Below you will find pricing details for storage and each frequency level.\nContact us if you need a custom service or pricing. The price is paid in Kenshi tokens.\nIf you encounter any issues with payments, contact us at\nsupport@kenshi.io.\nAll indexed data is geographically replicated to allow low latency queries from anywhere in\nworld. Indexing is done on  ALL  event fields, and all indexes are stored in memory to\nallow faster queries.\nIf you're not sure which plan fits your needs the best, you can contact us by sending an email to\ninquiries@kenshi.io or reaching out via one of our official\nsocial media links.\nKenshi charges $8 per month per gigabyte of indexed data. This data is geographically distributed\non five data servers. Every 1GB of data on each server is backed backed by 0.256GB of RAM.\nKenshi charges $49.99 for every 2,592,000 indexing runs. That means you'll pay $49.99 per month\nif your task runs every second, or half of that if it runs once every two seconds.\nContact us if you need to store more than 400GB of data, need to index events from a great number\nof contracts, or have any other unique requirements. The Kenshi Deep Index infrastructure runs\ncompletely serverless, is able to handle hundreds of thousands of events per second, and is able\nto index peta-bytes of data. Reach out to inquiries@kenshi.io\nfor inquiries or further details.\nTo get a grant on our services or to get a discount you can contact us at\ninquiries@kenshi.io.",
    "breadcrumb": [
      {
        "url": "/docs",
        "title": "Documentation"
      },
      {
        "url": "/docs/services",
        "title": "Services and Products"
      },
      {
        "url": "/docs/services/deep-index",
        "title": "Deep Index"
      },
      {
        "url": "/docs/services/deep-index/sync",
        "title": "Deep Index Sync"
      },
      {
        "url": "/docs/services/deep-index/sync/pricing",
        "title": "Deep Index Pricing"
      }
    ]
  },
  {
    "text": "Connection to a broker is done over WebSockets. Connection URL format is as follows:\nWhere:\nwss  - indicates that the connection is secure\nhostname  - the hostname of the broker\nport  - the port number of the broker\nprotocol  - the protocol version of the broker\nOnce the connection is established, the client must send a sequence of\nmessages to the broker to authenticate itself. Once the broker has verified\nthe client's identity, the client can start sending and receiving messages.\nThis process is demonstrated in the following diagram:\nsequenceDiagram\nactor Worker\npar Connection Initiation\nWorker->>+Broker: Hello\nBroker->>-Worker: KOSK Challenge\nactivate Worker\nWorker->>Broker: KOSK Response\ndeactivate Worker\nand\nConsumer->>+Broker: Hello\nBroker->>-Consumer: KOSK Challenge\nactivate Consumer\nConsumer->>Broker: KOSK Response\ndeactivate Consumer\nConsumer->>Broker: Subscribe\nend\nloop Send Verified Data\nWorker-->>Consumer: Send Data Through Broker\nend\nThe Hello message structure is as follows:",
    "breadcrumb": [
      {
        "url": "/docs",
        "title": "Documentation"
      },
      {
        "url": "/docs/unchained",
        "title": "Unchained"
      },
      {
        "url": "/docs/unchained/specs",
        "title": "Specification"
      },
      {
        "url": "/docs/unchained/specs/connection",
        "title": "Connection"
      }
    ]
  },
  {
    "text": "The Kenshi Deep Index MQL endpoint delivers accelerated, edge-optimized access\nfor querying and retrieving blockchain data using the powerful MongoDB Query\nLanguage (MQL). Enhance your data management and analysis capabilities with this\nstreamlined solution, designed for the modern blockchain ecosystem.\nTo learn more about MQL itself, you can visit the\nofficial MongoDB website.\nIntroduction to MQL\nGetting started with Deep Index\nMQL Endpoints\nMQL Examples\nDeep Index MQL Schema\nDeep Index MQL Pricing",
    "breadcrumb": [
      {
        "url": "/docs",
        "title": "Documentation"
      },
      {
        "url": "/docs/services",
        "title": "Services and Products"
      },
      {
        "url": "/docs/services/deep-index",
        "title": "Deep Index"
      },
      {
        "url": "/docs/services/deep-index/mql",
        "title": "MQL (MongoDB Query Language) for Deep Index"
      }
    ]
  },
  {
    "text": "On this page you can find examples for Node.js, Python and Go languages.\nUsing AxiosUsing Fetch\nThis example requires Node.js v14.8+ and the axios npm package installed.\nThis example is also available on GitHub.\nUsing Requests\nThis example requires the requests Python package installed.\nThis example is also available on GitHub.\nUsing Shurcool/GraphQL\nThis example requires the shurcool/graphql package installed.\nThis example is also available on GitHub.",
    "breadcrumb": [
      {
        "url": "/docs",
        "title": "Documentation"
      },
      {
        "url": "/docs/services",
        "title": "Services and Products"
      },
      {
        "url": "/docs/services/deep-index",
        "title": "Deep Index"
      },
      {
        "url": "/docs/services/deep-index/graphql",
        "title": "GraphQL for Deep Index"
      },
      {
        "url": "/docs/services/deep-index/graphql/examples",
        "title": "GraphQL Examples"
      }
    ]
  },
  {
    "text": "Unchained is a federated network of independent and self-hosted nodes with\ndifferent functions and responsibilities. Each instance is owned and operated by\na different person or organization and has its own rules and moderation\npolicies. This means that Unchained is not a single centralized service, but a\nnetwork of interconnected communities that share the same values and principles.\nA worker is a node that is responsible for processing and validating data that\nis requested either by the network or by other nodes. Workers are the backbone\nof the network and are responsible for maintaining the integrity and security of\nthe system.\nA broker is a node that acts as an intermediary between workers and consumers.\nBrokers are responsible for routing requests to the appropriate worker and\nensuring that the data is delivered in a timely and efficient manner.\nA consumer is a node that requests data from the network. Consumers can be\nindividual users, applications, or other nodes that need a piece of data to\nbe processed or validated.\nThe Unchained network is designed to be decentralized and resilient to\ncensorship and control. By distributing the responsibilities of processing and\nvalidating data across multiple nodes, the network can operate\nindependently of any single entity or organization.\nThe federated nature of the network also allows for greater diversity and\nflexibility in terms of governance and moderation. Each node is free to set its\nown rules and policies, which means that the network as a whole can\naccommodate a wide range of different communities and use cases.\nWith a federated network, each node is responsible for its data and resources,\nwhich means that the network as a whole is more resilient to attacks and\nfailures. In a peer-to-peer network, all nodes are equal and share the same\nresponsibilities, which can make the network more vulnerable to centralization\nand control.\nFurthermore, a federated network allows for greater scalability and efficiency\nby distributing the workload across multiple nodes. This means that the network\ncan handle a larger number of requests and process data more quickly and\nreliably.\nBy separating responsibilities between workers, brokers, and consumers, we allow\neach node to focus on its core functions and optimize its performance. Each node\ncan choose to specialize in a particular area or provide a general purpose\nservice to the network, which allows for greater diversity and innovation in the\necosystem.\nFor example, a worker node might specialize in processing large datasets\nperforming complex computations, or to simply signing and sending sensor data on\na small IoT device. A broker node might specialize in routing requests to the\nappropriate worker or optimizing the network topology for better performance.\nA consumer node might specialize in aggregating data from multiple sources or\nproviding a user-friendly interface for interacting with the network. Consumers\nare also free to store data in different backends. For example, a consumer might\nchoose to store data in a decentralized storage network like IPFS or a\ntraditional cloud storage provider like AWS or send it to a blockchain\n(Oracles).\nBy allowing each node to focus on its core functions, we can create a more\nefficient and resilient network that can adapt to a wide range of different use\ncases and requirements.",
    "breadcrumb": [
      {
        "url": "/docs",
        "title": "Documentation"
      },
      {
        "url": "/docs/unchained",
        "title": "Unchained"
      },
      {
        "url": "/docs/unchained/specs",
        "title": "Specification"
      },
      {
        "url": "/docs/unchained/specs/federation",
        "title": "Federated Network"
      }
    ]
  },
  {
    "text": "The Kenshi Deep Index Sync enables efficient blockchain data indexing, providing\nseamless retrieval, storage, and integration of vital blockchain data into\nKenshi's robust database clusters. Access and analyze this information\neffortlessly with the Kenshi Deep Index GraphQL endpoint, MQL endpoint, or the\nKenshi Reverse-API service, delivering versatile options for data consumption in\nthe blockchain ecosystem.\nIntroduction to Deep Index Sync\nGetting started with Deep Index\nMetadata API\nDeep Index Example\nDeep Index Pricing",
    "breadcrumb": [
      {
        "url": "/docs",
        "title": "Documentation"
      },
      {
        "url": "/docs/services",
        "title": "Services and Products"
      },
      {
        "url": "/docs/services/deep-index",
        "title": "Deep Index"
      },
      {
        "url": "/docs/services/deep-index/sync",
        "title": "Deep Index Sync"
      }
    ]
  },
  {
    "text": "There are a few security considerations and best practices to take into account when\ncreating a custom oracle and deploying it to the Kenshi Oracle Network. Although not\nrequired, they are highly recommended.\nYou should always verify the sender address of the caller to your callback function.\nIf it is not the address of your oracle or an address you do not trust, you must revert\nthe transaction. To view the sender address of your Kenshi Oracle, head to the Kenshi\nOracle Network dashboard, select your oracle, and view the address in the \"Add Credit\"\ntab.\nGas fees stored in associated gas wallets are not insured. Kenshi protects the stored\ngas on a best effort basis. Addresses are derived from a common BIP39 seed, stored in\na secret manager for API usage. Make sure you do not supply more gas than your oracle\nneeds. You can always check the balance of this address in a call to your oracle endpoint\nand supply more gas if needed.\nKenshi caches requests as to not send an event for processing twice, and to not deliver it\nto your smart contract twice. In case of retries, Kenshi re-sends events to your endpoint\nto get fresh data (this is useful if you're checking for market data, weather data, or any\ndata that changes frequently).\nWhile Kenshi tries its best to prevent double-deliveries, you must make sure your smart contracts\nare idempotent. You can assign a unique \"requestId\"\nor \"nonce\" to each request on the blockchain and revert a transaction if it tries to re-deliver\nresults for an already fulfilled request.\nIt is quite easy to manipulate certain types of data. For example, if you are working with market\ndata, an attacker could put an order when the market conditions are in their favor. To prevent\nsuch attacks you can employ an averaging mechanism that best fits your use case (for example, use\na one hour average or percentile of an asset's price, instead of its spot price).\nCertain types of data are easily verifiable on the blockchain. For example, randomness generated\nby a VRF. Other types of data, such as market data, sport or weather are not so verifiable. However,\nit is easy to verify the sender of such data, and to make sure they are not manipulated after being\ngenerated and verified by your oracle endpoint.\nYou can use EIP712 to sign and later verify them on\nthe blockchain.\nChoose an appropriate number for block confirmations if sensitive business logic or transfer of funds\nis involved. A transaction can revert, get reorganized or get cancelled before finality is reached.\nLearn more about finality here.",
    "breadcrumb": [
      {
        "url": "/docs",
        "title": "Documentation"
      },
      {
        "url": "/docs/services",
        "title": "Services and Products"
      },
      {
        "url": "/docs/services/oracle-network",
        "title": "Oracle Network"
      },
      {
        "url": "/docs/services/oracle-network/custom",
        "title": "Custom Oracles"
      },
      {
        "url": "/docs/services/oracle-network/custom/security",
        "title": "Security Considerations"
      }
    ]
  },
  {
    "text": "Follow below instructions to install the Kenshi blockchain IoT SDK\nfor your favorite platform.\nTo install the Kenshi IoT SDK for Arduino, go to the Kenshi IoT SDK\nrelease page on Github\nand download the latest release.\nThen open the Arduino IDE and select Sketch > Include Library > Add ZIP Library...\nlike the image below:\nNow select the downloaded file and wait for the install to finish.\nThe Kenshi IoT SDK for Arduino has full support for ESP32 boards using the ESP32\nnative libraries. Follow the same instructions as Arduino boards to install the SDK\nfor ESP32.\nTo bootstrap a Zephyr project with the Kenshi IoT SDK, you can run the following\ncommands:\nAlternatively, to add the SDK to an existing project, first find the path to your\nwest manifest by running this command:\nNow open the west manifest file in the editor of your choice and add the following\nin the projects section:\nNow run:\nYou can include the Kenshi SDK into your application by adding the following to your\nZephyr project's configuration file:\nNote that the Kenshi IoT library for Zephyr depends on the following (or similar)\nconfiguration options, which also need to be added to your project's configuration\nfile:\nYou can use your favorite HTTP or GraphQL client on these boards\nfor communicating with the Kenshi Deep Index. Read the documentation\nhere.",
    "breadcrumb": [
      {
        "url": "/docs",
        "title": "Documentation"
      },
      {
        "url": "/docs/services",
        "title": "Services and Products"
      },
      {
        "url": "/docs/services/iot",
        "title": "Kenshi IoT SDK"
      },
      {
        "url": "/docs/services/iot/install",
        "title": "Install"
      }
    ]
  },
  {
    "text": "The Kenshi Deep Index endpoint for GraphQL provides an accelerated and edge optimized access point\nfor querying and retrieving blockchain data using GraphQL.\nGraphQL is an open-source data query and manipulation language for APIs, and a runtime for\nfulfilling queries with existing data.\n[wikipedia]\nTo learn more about GraphQL itself, you can visit the official GraphQL website.\nIntroduction to GraphQL\nGetting Started with GraphQL\nGraphQL Endpoints\nGraphQL Examples\nDeep Index GraphQL Schema\nDeep Index GraphQL Pricing",
    "breadcrumb": [
      {
        "url": "/docs",
        "title": "Documentation"
      },
      {
        "url": "/docs/services",
        "title": "Services and Products"
      },
      {
        "url": "/docs/services/deep-index",
        "title": "Deep Index"
      },
      {
        "url": "/docs/services/deep-index/graphql",
        "title": "GraphQL for Deep Index"
      }
    ]
  },
  {
    "text": "You can find here the technical documentation and specifications of the\nUnchained Network.\nThis is a work in progress\nFederated Network\nRPC\nConnection\nUnchained Address",
    "breadcrumb": [
      {
        "url": "/docs",
        "title": "Documentation"
      },
      {
        "url": "/docs/unchained",
        "title": "Unchained"
      },
      {
        "url": "/docs/unchained/specs",
        "title": "Specification"
      }
    ]
  },
  {
    "text": "Unchained is a decentralized, federated network for data validation. Unchained\nnodes work to validate data together and are rewarded in KNS tokens. It is also\npossible to run Unchained as a private or local network, or independently as a\npart of a bigger application.\nUnchained has the capability to index data from any blockchain, act as a message\nbroker between different blockchains, and supply verified data to smart\ncontracts and oracles. However, its primary purpose goes beyond just serving as\na connector between on-chain and off-chain environments, or providing data to\nexisting blockchains.\nUnchained is a standalone platform suitable for various applications that need\nvalidated and verified data. This data remains valuable even without being sent\nto the blockchain. Unchained enables direct use of verified data by analytical\ntools, data explorers, for training AI models, or any other use case requiring\ntrusted data.\nMoreover, the Unchained network offers not just raw data, but also the necessary\ntools for data processing and analysis. It can be used as a grid computing\nplatform where users lend their computation power to the consumers, or as an\nedge computing platform where users are re-routed to the nearest available node.\nTo achieve its objectives, Unchained is not required to function as a blockchain\nin the traditional sense, where data is organized chronologically, compiled into\nblocks, and linked sequentially to the preceding ones. Unchained allows its\nnodes the flexibility to validate and verify data at their own pace. Unlike\ntraditional blockchain models where there's competition to propose a block, in\nUnchained, each piece of data validated by a peer is acknowledged and recorded\nby other peers as additional verification.\nNodes within Unchained are not obligated to focus on identical data sets. Each\npeer has the autonomy to choose which data to validate and store, and which to\nbypass for any given reason. This approach grants Unchained exceptional\nflexibility and scalability, as data is effectively sharded and made available\non a demand-driven basis.\nThe consensus mechanism in Unchained is multifaceted. The first aspect concerns\nhow peers communicate and acknowledge data within the network. The networking\nmodel in Unchained is federated. Nodes in this federated network can assume\ndifferent roles; workers, for example, have the task of sourcing, validating,\nand processing data, while brokers are tasked with re-routing messages and\nsupervising the workers.\nThe federated network and the separation in functionality allows\nresource-constraint devices to join the Unchained network and benefit from its\nfeatures as well. As an example, a small IoT sensor can send validated sensor\ndata to Unchained without the need of running a \"full\" node, or a small device\ncan call a computationally heavy algorithm on the Unchained grid and harness its\ncomputation power.\nIn situations where nodes present different values for a specific data metric\n(M), or the result of a process, the resolution hinges on the voting power of\neach validator. This is where\nLiquid Proof of Stake (LPoS) comes into play.\nThe voting power of each node is determined by the amount of KNS tokens they\nhave staked, plus any staked Katana NFTs, and any KNS tokens or Katana NFTs\ndelegated to them by the other users.\nConsumers or peers assessing the validity of data must consider the aggregated\nvoting powers backing the different reported values for each dataset or\ncomputation. A threshold is set by the consumers (e.g., +51% or +90%), above\nwhich data is deemed valid. This mechanism ensures that the majority decision,\nweighted by stake, dictates the accepted truth within the network.\nThe LPoS system offers several advantages. It aligns validators' incentives with\nthe network's health and integrity, as their influence depends on their stake.\nThis reduces the likelihood of malicious behavior, as acting against the\nnetwork's interests would directly impact a validator's own stake.\nAdditionally, LPoS enables more dynamic participation and decentralization, as\nstakeholders can delegate their tokens, thus contributing to the network's\ngovernance without being active validators themselves. This method also allows\nfor more flexibility and diversity in network decision-making, as it\nincorporates the perspectives of a broader range of participants.\nUnchained implements the BLS12-381 algorithm combined with proof of Knowledge of\nSecret Key (KOSK) and signature aggregation. The BLS12-381 algorithm is a\ncryptographic pairing function that enables efficient and secure elliptic curve\noperations. This algorithm is particularly known for its strength and efficiency\nin smaller-sized keys compared to other cryptographic algorithms.\nProof of Knowledge of Secret Key (KOSK) is a critical component in this setup.\nIt ensures that only the holder of the private key can produce a valid\nsignature, preventing Rogue Public Key attacks on aggregated signatures. The\nsignature itself cannot be used to derive the private key, adding an extra layer\nof protection.\nSignature aggregation allows multiple signatures to be combined into a single,\ncompact signature. The benefits of signature aggregation are significant,\nespecially in terms of scalability and efficiency. It reduces the amount of data\nthat needs to be transmitted and stored, which is particularly advantageous in a\nsystem where numerous transactions or validations occur. This not only saves\nspace but also reduces processing time, making the system efficient and fast.\nFor Liquid Proof of Stake (LPoS) and Remote Procedure Call (RPC) requests,\nUnchained adopts the SECP256K1 cryptographic algorithm, the same as used by\nEthereum. This choice is primarily to maintain compatibility with Ethereum,\nfacilitating interactions and integrations between Unchained and Ethereum-based\nsystems.\nSECP256K1 is an elliptic curve algorithm widely used in blockchain technologies,\nparticularly known for its application in Ethereum's transaction signing\nprocess. By using this algorithm, Unchained ensures that its platform can\nseamlessly interact with Ethereum's network and services. This compatibility is\ncrucial for users and applications that operate across both Unchained and\nEthereum platforms, as it simplifies processes and enhances user experience by\nallowing the use of the same cryptographic standards and tools.",
    "breadcrumb": [
      {
        "url": "/docs",
        "title": "Documentation"
      },
      {
        "url": "/docs/unchained",
        "title": "Unchained"
      },
      {
        "url": "/docs/unchained/about",
        "title": "About"
      }
    ]
  },
  {
    "text": "Experience the power of Kenshi Deep Index, an advanced blockchain data indexing\nand processing solution designed for seamless data consumption and efficient\nevent management. Harness the benefits of rapid querying, in-depth analysis, and\nstreamlined integration with smart contracts, all within a user-friendly\nplatform tailored for the modern blockchain ecosystem.\nThe Kenshi Deep Index service consists of multiple services for retrieving,\nquerying, and processing blockchain data:\nSync  can be used to retrieve, store, and index data on the Kenshi database clusters.\nGraphQL and MQL  can be used to query, search and retrieve synced blockchain data in your apps.\nReverse-API  can be used to get notifications about new blockchain events on your HTTP endpoints.\nThis service is available on Ethereum (ETH), Arbitrum (ETH), BNB Smart Chain (BSC),\nFantom (FTM), Polygon (MATIC), Avalanche (AVAX), Bitgert (BRISE), and Aurora (AURORA)\ntestnets and mainnets.\nIf you need any help, don't hesitate to join our communities\nor send us an email at support@kenshi.io.\nDeep Index Sync\nGraphQL for Deep Index\nMQL (MongoDB Query Language) for Deep Index\nReverse API for Deep Index",
    "breadcrumb": [
      {
        "url": "/docs",
        "title": "Documentation"
      },
      {
        "url": "/docs/services",
        "title": "Services and Products"
      },
      {
        "url": "/docs/services/deep-index",
        "title": "Deep Index"
      }
    ]
  },
  {
    "text": "Installation with Docker or running the Unchained Go client directly are\ncurrently the only officially supported ways of installing Unchained.\nThe following operating systems are  officially  supported:\nLinux : Any Linux distro running the Linux kernel v5.15+, with systemd.\nmacOS : macOS v12+ running on an  official  Apple hardware.\nWindows : Windows 10 Vibranium and above, or Windows Server 20H2 and above.\nAlways make a backup of your secret keys before an update\nIf you'd like to run Unchained with Docker, you can run the following command in\na new empty directory:\nRun again in the same directory and follow the instructions to update.\nFor advanced use cases it is better to install and run the Unchained client\ndirectly. To do so, run the following command:\nHead to the Unchained\nreleases page and grab\nthe latest release for Docker. Unzip the release file and switch to the newly\ncreated directory.\nHead to the Unchained\nreleases page and grab\nthe latest release for your OS and CPU architecture. Move the binary file to an\nappropriate place and make it executable:",
    "breadcrumb": [
      {
        "url": "/docs",
        "title": "Documentation"
      },
      {
        "url": "/docs/unchained",
        "title": "Unchained"
      },
      {
        "url": "/docs/unchained/nodes",
        "title": "Running a Node"
      },
      {
        "url": "/docs/unchained/nodes/install",
        "title": "Installing the Unchained Client"
      }
    ]
  },
  {
    "text": "Once you have Unchained installed, you need to configure a few things first.\nIf you are running Unchained with Docker, your configuration file will be at\nthe following path from in your installation directory:\nYou can find your secrets file at:\nIf you are running Unchained directly, you can pass the path to your config file\nusing -c, and the path to your secrets file using -s. You can also specify the\npath to the context DB directory using -x.\nThe default values are:\nConfig file : ./conf.yaml\nSecrets file : ./secrets.yaml\nContext DB : ./context\nThe minimum required config for running a worker node is the following:\nPlease note that the value <NODE_NAME> and <ETHEREUM_RPC_ADDRESS>\nvalues need to be modified.\nThis section is a work in progress. See\nA Practical Guide to Unchained: Index Events and Token Prices on Any EVM Chain.",
    "breadcrumb": [
      {
        "url": "/docs",
        "title": "Documentation"
      },
      {
        "url": "/docs/unchained",
        "title": "Unchained"
      },
      {
        "url": "/docs/unchained/nodes",
        "title": "Running a Node"
      },
      {
        "url": "/docs/unchained/nodes/configure",
        "title": "Configuring the Unchained Client"
      }
    ]
  },
  {
    "text": "You can find here the instructions on how to run an Unchained node on the public\nUnchained network, as a private network, a local network, or as an independent\ndata validator.\nHardware Requirements\nInstalling the Unchained Client\nConfiguring the Unchained Client\nRunning the Unchained Client",
    "breadcrumb": [
      {
        "url": "/docs",
        "title": "Documentation"
      },
      {
        "url": "/docs/unchained",
        "title": "Unchained"
      },
      {
        "url": "/docs/unchained/nodes",
        "title": "Running a Node"
      }
    ]
  },
  {
    "text": "Unchained is a decentralized, federated network for data indexing, validation,\nanalysis, processing, and delivery.\nUnchained can be used as:\nA federated  public network  with centralized or decentralized\nconsensus where nodes work for a common goal.\nA federated  private  or  local  network with full data privacy and custom rulesets.\nA  standalone  application as a part of a bigger architecture.\nUnchained can be used for:\nIndexing data from on-chain or off-chain sources.\nDelivering data to on-chain or off-chain consumers (e.g. Oracles or webhooks).\nValidating data for analytical or practical purposes (e.g. dashboards or AI).\nRunning computational heavy tasks in a verified, validated way.\nThis section of the Kenshi documentation is a work in progress.\nAbout\nRunning a Node\nResources\nLicense\nSpecification",
    "breadcrumb": [
      {
        "url": "/docs",
        "title": "Documentation"
      },
      {
        "url": "/docs/unchained",
        "title": "Unchained"
      }
    ]
  },
  {
    "text": "Below you can find a few sample oracles demonstrating how to develop custom oracles on\ntop of the Kenshi Oracle Network.\nThese examples are not production ready and are provided without any warranty.\nThe time oracle is one of the simplest oracles you can make. It might not do much, but it\nshows exactly how you can make your custom oracle.\nOracleSmart contract\nThis example can be deployed to AWS Lambda.\nThe following example shows how to get price data from coingecko.com.\nOracleSmart contract\nThis example can be deployed to AWS Lambda. It requires\nethers and node-fetch libraries to be installed.\nThe following example shows how to get weather data from brightsky.dev.\nOracleSmart contract\nThis example can be deployed to AWS Lambda. It requires\nethers and node-fetch libraries to be installed.\nSolidity doesn't have support for floating point numbers. We multiply all floating\npoint numbers by 100 and turn them into whole numbers for a 0.01 precision.\nThe following example shows how to check if the user owns a specific amount of tokens\nor NFTs on another chain.\nOracleSmart contract\nThis example can be deployed to AWS Lambda. It requires\nethers library to be installed.\nThe following example shows how to create your own VRF oracle. This example uses the\nKenshi VRF libraries, which implement draft 10 of the IETF ECVRF.\nOracleSmart contract\nThis example can be deployed to AWS Lambda. It requires\nelliptic and @kenshi.io/node-ecvrf library to be installed.\nThis example requires the @kenshi.io/vrf-consumer library.",
    "breadcrumb": [
      {
        "url": "/docs",
        "title": "Documentation"
      },
      {
        "url": "/docs/services",
        "title": "Services and Products"
      },
      {
        "url": "/docs/services/oracle-network",
        "title": "Oracle Network"
      },
      {
        "url": "/docs/services/oracle-network/custom",
        "title": "Custom Oracles"
      },
      {
        "url": "/docs/services/oracle-network/custom/blueprints",
        "title": "Blueprints"
      }
    ]
  },
  {
    "text": "Kenshi Oracle Network enables developers to make their custom oracles using the\ntechnologies they already know and use. Continue reading to learn more about the\nfeatures offered by the Oracle Network and how to create and deploy your Oracle.\nYou can use the Arbitrum One Kenshi tokens to pay for any of the Kenshi services\non any of the supported chains.\nBe sure to read the security considerations before deploying your oracle.\nThis service is deprecated in favor of the new Unchained software and is no longer\navailable for new customers. If you are an existing customer, you can still manage your\noracles.\nFeatures\nGetting started\nCustom Oracle Protocol\nSecurity Considerations\nBlueprints\nPrice",
    "breadcrumb": [
      {
        "url": "/docs",
        "title": "Documentation"
      },
      {
        "url": "/docs/services",
        "title": "Services and Products"
      },
      {
        "url": "/docs/services/oracle-network",
        "title": "Oracle Network"
      },
      {
        "url": "/docs/services/oracle-network/custom",
        "title": "Custom Oracles"
      }
    ]
  },
  {
    "text": "The Kenshi VRF oracle implements a request-response message exchange pattern.\nThat means your smart contract needs to ask for a random number first, then\nwait until our oracle answers to this random number request.\nWe implement and provide a Solidity VRF consumer library you can use for\nautomatically handling the steps required for requesting and receiving a random\nnumber. If you are interested in knowing how the process works you can read more\nabout the detailed steps in the \"Kenshi VRF Workflow\" section below.\nIf you are using Hardhat or Truffle for development, you can install the Kenshi\nVRF consumer library using the following commands:\nWith NPMWith Yarn\nKenshi dashboard can be to used create a VRF subscription.\nA subscription maps a Kenshi payment to one or more contracts that use the Kenshi VRF.\nEvery time one of these contracts requests a VRF, the price for delivering the VRF to that\ncontract is reduced from the credit charged to the subscription.\nThis reduces gas fees and VRF delivery prices significantly, making it cheaper to\nrequest randomness on the blockchain.\nTo fill the form, you can refer to the following guide:\nChain  is the chain you are targeting. This is the chain where your smart contract is deployed to.\nCredit  is the amount of Kenshi you want to send to this subscription. This amount is consumed\nfor paying the VRF fees requested by the  allow  list.\nThe  allow  list is a list of smart contract addresses you want to use this subscription for.\nThese addresses must be checksummed.\nKenshi implements the latest Goldberg ECVRF draft public by IETF. The latest version\nof the original VRF document can be found on the IETF\ndatatracker.\nKenshi also publishes libraries for Node.js and Solidity that can be used for testing\nthe VRF functionality locally or other development purposes:\nNode.js library\nSolidity library\n(located in \"contracts/lib\" directory and \"contracts/VRFUtils.sol\")\nTo use the Kenshi VRF oracle for requesting random numbers, follow the steps below.\nInstall and import the Kenshi VRF consumer library\nInherit from the \"VRFConsumer\" smart contract\nCall the \"setupVRF\" function with appropriate arguments\nImplement a \"fulfillRandomness\" function\nCall the \"requestRandomness\" function any time you need a new random number\nAn example of doing this can be found here.\nThe \"randomness\" provided to your smart contract is an unsigned integer ranging\nfrom \"0\" to \"2**256 - 1\". If you need a number \"K\" between a \"X\" and \"Y\" you\ncan use the following formula:\n\"X\" being the smaller number. For example, to get a number between \"20\" and \"80\"\nyou should use:\nThe Kenshi VRF oracle tries reporting the random number back to your contract\na few times on different intervals before giving up. Failure to report a random\nnumber can be caused by several factors such as network congestion or simply your\ncontract lacking enough Kenshi for paying the VRF fees.\nEach time your smart contract calls the \"requestRandomness\" method of the Kenshi\nVRF coordinator, it receives a \"requestId\". The Kenshi VRF coordinator keeps record\nof the \"requestId\" for your smart contracts and increments it by one every time this\nfunction is called from your smart contract.\nAn event is then emitted from the VRF coordinator that includes this \"requestId\"\nas well as the address of your smart contract. This event is then picked up by the\nKenshi Deep Index Sync oracle, and passed to the Kenshi VRF oracle using the Kenshi\nDeep Index Event Dispatcher.\nNext the oracle combines the following parameters to create an alpha string that is\nused for random number generation according to the Goldberg ECVRF draft 10 standard:\nUsing the alpha constant and the draft 10 \"ECVRF-SECP256K1-SHA256-TAI\" cipher suite,\nthe Kenshi oracle generates the requested random number. After estimating the gas fee\nneeded for delivering it to your contract, it calls the \"fullfillRandomnessForContract\"\nfunction of the VRF coordinator.\nThis function then transfers enough Kenshi for paying the gas-fees as well as the VRF\ngeneration fees from your contract address to our payment collector address. If the\ntransfer is successful the random number is delivered to your smart contract by calling the\n\"onRandomnessReady\" function inherited from the Kenshi \"VRFConsumer\" library in\nyour smart contract.\nIn case you set the \"verify\" parameter of the \"VRFConsumer\" to \"true\", the \"VRFConsumer\"\nverifies the received random number using the proof provided the Kenshi VRF oracle. This is\ndone by calling the \"VRFUtils\" contract deployed to the same chain as your smart contract.\nThe call reverts if the proof for the random number is invalid. When all the above steps are\nexecuted successfully, the \"fulfillRandomness\" function is called on your smart contract,\npassing the \"requestId\" and the \"randomness\".",
    "breadcrumb": [
      {
        "url": "/docs",
        "title": "Documentation"
      },
      {
        "url": "/docs/services",
        "title": "Services and Products"
      },
      {
        "url": "/docs/services/oracle-network",
        "title": "Oracle Network"
      },
      {
        "url": "/docs/services/oracle-network/vrf",
        "title": "VRF Oracle"
      },
      {
        "url": "/docs/services/oracle-network/vrf/start",
        "title": "Getting Started with Kenshi VRF"
      }
    ]
  },
  {
    "text": "Check the arduino\ndirectory on Github for header files and samples.\nThe Kenshi IoT SDK for Arduino/ESP32 implements the Kenshi Deep Index MQL API. Since\nthe API endpoint for the Kenshi Deep Index MQL API is available only over HTTPS, you\nneed to have a secure network Client.\nOn ESP32 the HTTPS connection is handled by the SDK automatically; all you need is to\nbe connected to a Wi-Fi access point. On certain Arduino boards, however, you need to\nmanage the HTTPS connection yourself. For example, on Arduino MKR 1010, you should use\nan instance of \"WiFiSSLClient\", but you won't need to register the Kenshi/AWS root\ncertificate as it is already shipped with the Arduino MKR 1010. Refer to the developer\ndocumentation of your board to learn how you can install a root certificate. Check\n\"The Kenshi root certificate\" section on this page\nto learn how to get the certificate.\nOnce you are connected to the internet and have the Kenshi SSL certificate set up, you\ncan create instances of MQL or SyncTask and start making requests. To make a query, you\nmust use the MongoDB Query Language. You will receive MongoDocuments in response. Refer\nto the Kenshi MQL documentation to learn more about\nthe query language or the response schema.\nKenshi IoT SDK for Arduino/ESP32 uses the ArduinoJson\npackage for building queries and parsing MQL responses. To learn more, refer to the\nArduinoJson documentation.\nFull examples are provided for Arduino MKR 1010 and ESP32 on Kenshi IoT SDK\nrepository on\nGithub.\nThis section lists all enum, class, and other objects exported by \"Kenshi.h\".\nThis enum contains all the blockchains supported by this SDK.\nUse values from this enum to initialize your MQL objects.\nThis class allows communicating with the Kenshi Deep Index MQL endpoint.\nTo initialize an instance of this class, you need an API key, the address\nof the API key owner, and a blockchain from the Blockchain enum.\nOn Arduino, you need to pass a network Client instance to the \"runQuery\"\nmethod of the MQL class. This instance can be any network Client instance\nsuch as WiFiClient, EthernetClient or GSMClient.\nThe SyncTask class can be used to check on the sync state of\na certain task. This is useful when you only want to process\nthe events emitted  after  your device starts up.\nThis is the root certificate for the \"api.kenshi.io\" domain. You need to pass this\nto your secure Client instance on specific boards.\nCheck the zephyr\ndirectory on Github for header files and samples.\nThe Kenshi IoT SDK for Zephyr comes with a lower level API compared to the Arduino\nlibrary and is meant for advanced users. This library supports any HTTPS-capable\ndevelopment board supported by Zephyr.\nFor normal usage, the SDK defines four C preprocessor macros. The \"MQL_INIT\" macro\nis used to define initialize MQL structs and functions required for building, parsing,\nand serializing MQL queries and MQL responses. The \"MQL_CALLBACK\" is used to define\na callback to be called when the MQL responses are ready. The \"MQL_QUERY\" macro is\nused to create an MQL query, and the \"MQL_GET_EVENTS\" is used afterwards to send the\ncreated query.\nFor more advanced usage, you can check the \"kenshi.h\" header file.\nThis section lists all enum, class, and other objects exported by \"kenshi.h\".\nThis macro is used to initialize the structs and functions needed to build, parse,\nand serialize MQL queries.\nThis macro is used to create a callback to be called when the MQL\nresults are ready.\nThis macro is used to create an MQL query.\nThis macro is used to send an MQL query and wait for a response.",
    "breadcrumb": [
      {
        "url": "/docs",
        "title": "Documentation"
      },
      {
        "url": "/docs/services",
        "title": "Services and Products"
      },
      {
        "url": "/docs/services/iot",
        "title": "Kenshi IoT SDK"
      },
      {
        "url": "/docs/services/iot/reference",
        "title": "IoT SDK library reference"
      }
    ]
  },
  {
    "text": "On this page you can find the contract addresses for the BNB Chain,\nPolygon, Fantom, Avalanche (C-Chain),\nand the Ethereum (Goerli) chains. These contract addresses\nshould be passed to the \"setupVRF\" function depending on which chain your contract is deployed to.\nThis service is available only on the BNB Chain (BSC),\nFantom (FTM) and Polygon (MATIC) testnets and mainnets. If you have any issues or questions\nyou can join our Telegram chat or send us an email\nat support@kenshi.io.",
    "breadcrumb": [
      {
        "url": "/docs",
        "title": "Documentation"
      },
      {
        "url": "/docs/services",
        "title": "Services and Products"
      },
      {
        "url": "/docs/services/oracle-network",
        "title": "Oracle Network"
      },
      {
        "url": "/docs/services/oracle-network/vrf",
        "title": "VRF Oracle"
      },
      {
        "url": "/docs/services/oracle-network/vrf/contracts",
        "title": "VRF Contracts Addresses"
      }
    ]
  },
  {
    "text": "The Kenshi Blockchain IoT SDK is a revolutionary solution designed to empower\nIoT and embedded devices with seamless integration to receive and process\nblockchain events. Enhance your connected systems' capabilities and harness\nblockchain technology's power with this user-friendly and versatile SDK tailored\nfor the rapidly evolving IoT landscape.\nInstall\nIoT SDK Examples\nIoT SDK library reference\nSupported devices",
    "breadcrumb": [
      {
        "url": "/docs",
        "title": "Documentation"
      },
      {
        "url": "/docs/services",
        "title": "Services and Products"
      },
      {
        "url": "/docs/services/iot",
        "title": "Kenshi IoT SDK"
      }
    ]
  },
  {
    "text": "VRFs play an important role in the blockchain, as the blockchain lacks the native functionality\nto generate random numbers securely because of its deterministic nature.\nVRFs can be used to implement dynamic NFTs, cryptocurrency betting systems, metaverses assets,\ncryptocurrency games, or anywhere on the blockchain where a random number is needed.\nThis service is deprecated in favor of the new Kenshi Oracle Network.\nKenshi Verifiable Random Function oracles can generate and verify pseudorandom numbers\nto be used by smart contracts on-chain. These random numbers are safe, secure, and tamper-proof.\nTheir fairness and derivation are verifiable by the receiving party. This verification proves that\nthey are not modified nor tampered with when transferred from source to destination.\nIn cryptography, a verifiable random function (VRF) is a public-key pseudorandom function that\nprovides proofs that its outputs were calculated correctly. The owner of the secret key can compute\nthe function value as well as an associated proof for any input value. Everyone else, using the\nproof and the associated public key (or verification key), can check that this value was indeed\ncalculated correctly, yet this information cannot be used to find the secret key.\n[wikipedia]\nYou can find details on the Kenshi VRF oracle implementation as well as guides for integrating\nit into your smart contracts in the following sections.\nGetting Started with Kenshi VRF\nVRF API Interface\nVRF Contracts Addresses\nVRF Examples\nVRF Retry Policy\nVRF Pricing",
    "breadcrumb": [
      {
        "url": "/docs",
        "title": "Documentation"
      },
      {
        "url": "/docs/services",
        "title": "Services and Products"
      },
      {
        "url": "/docs/services/oracle-network",
        "title": "Oracle Network"
      },
      {
        "url": "/docs/services/oracle-network/vrf",
        "title": "VRF Oracle"
      }
    ]
  },
  {
    "text": "Welcome to the Kenshi Oracle Network, a groundbreaking\nframework designed to revolutionize creating, deploying, and operating custom\noracles in EVM-based blockchain networks. Unleash the full potential of custom\noracles and enhance your platform's capabilities with this cutting-edge,\nuser-friendly and versatile solution crafted for the ever-evolving blockchain\nlandscape.\nThe Kenshi Oracle Network is a high-performance asynchronous oracle network\nbuilt as a platform for hosting custom oracles:\nThis service is available on Ethereum (ETH), Arbitrum (ETH), BNB Smart Chain (BSC),\nFantom (FTM), Polygon (MATIC), Avalanche (AVAX), Bitgert (BRISE), and Aurora (AURORA)\ntestnets and mainnets.\nIf you need any help, don't hesitate to join our communities\nor send us an email at support@kenshi.io.\nVRF Oracle\nCustom Oracles",
    "breadcrumb": [
      {
        "url": "/docs",
        "title": "Documentation"
      },
      {
        "url": "/docs/services",
        "title": "Services and Products"
      },
      {
        "url": "/docs/services/oracle-network",
        "title": "Oracle Network"
      }
    ]
  },
  {
    "text": "Here you can find a list of Kenshi products and services.\nYou can use the Arbitrum One Kenshi tokens to pay for any of the Kenshi services\non any of the supported chains.\nDeep Index\nOracle Network\nKenshi IoT SDK\nProduct Development",
    "breadcrumb": [
      {
        "url": "/docs",
        "title": "Documentation"
      },
      {
        "url": "/docs/services",
        "title": "Services and Products"
      }
    ]
  },
  {
    "text": "Last updated: 12.01.2023\nWelcome to Kenshi! By using our website or the provided services, you acknowledge that you have read,\nunderstood, and agree to be bound by our Terms and Conditions. These Terms and Conditions unconditionally\nextend and apply to all related applications, internet services, or website extensions. If you do not\nagree with all of these Terms and Conditions, you are prohibited from using this Website and may\ndiscontinue use immediately. Kenshi recommends that you save or print a copy of these Terms and Conditions\nfor future reference.\nKenshi Terms And Conditions (these \"Terms\" or these \"Terms and Conditions\") contained in this Agreement\nshall govern your use of this Website and all its content (collectively referred to herein as this\n\"Website\"). These Terms outline the rules and regulations guiding the use of Kenshi, located at\nhttps://timeleap.swiss. All materials/information/documents/services or all other entities (collectively\nreferred to as content) that appear on the Kenshi shall be administered subject to these Terms and\nConditions. These Terms and Conditions apply in full force and effect to your use of this Website,\nand the use of this Website constitutes an express agreement with all the terms and conditions\ncontained herein in full. Do not continue to use this Website if you have any objection to any of the\nTerms and Conditions stated on this page.\nThe following definitions apply to these Terms and Conditions, Privacy Statement, Disclaimer Notice,\nand all Agreements: \"User,\" \"Visitor,\" \"Client,\" \"Customer,\" \"You,\" and \"Your\" refers to you, the person(s)\nthat use this Website. \"Kenshi,\" \"We,\" \"Our,\" and \"Us\" refers to our Website/Company. \"Party,\" \"Parties,\" or\n\"Us\" refers to both you and us. All terms refer to all considerations of Kenshi necessary to undertake\nsupport to you for the express purpose of meeting your User needs in respect of our services, under and\nsubject to prevailing law of the state or country in which Kenshi operates (Vaud, Switzerland). Any use\nof these definitions or other glossary in the singular, plural, capitalization, and pronoun are\ninterchangeable but refer to the same.\nOther than the content you own and opted to include on this Website, under these Terms, Kenshi and its\nlicensors own and reserve all intellectual property rights of this Website. You are granted a limited\nlicense for viewing this Website's content, subject to the restrictions entailed in these Terms and Conditions.\nThe content of this Website is not intended for use or distribution to any person or entity in any\njurisdiction, geographical location, or country/state where such use or distribution will be contrary\nto the laws and regulations or subject Kenshi to any form of registration, claims, demands, costs, liabilities,\ndamages, or expenses.\nThe Website is intended for users at least 18 years of age. If you are under 18, you cannot use or register\nto use this Website or its services without parental permission or consent. By agreeing to these Terms and\nConditions, you have the legal capacity to comply and be bound by these Terms and Conditions.\nYou may use this Website as permitted by these Terms and Conditions and may not use this Website for any\npurpose other than for which Kenshi makes the Website and its services available.\nKenshi employs the use of cookies. By accessing Our Website, You agree to use cookies in Agreement with\nour Cookie Policy.\nOur interactive Website's optimal functionality uses cookies to retrieve the User's information for each\nvisit. Some of our affiliate partners may also use cookies.\nUnless otherwise stated, Kenshi and its licensors own the intellectual property rights for all content\non Kenshi. All intellectual property rights are reserved. You may access any Website content from Kenshi\nfor your personal use subject to restrictions set in these terms and conditions.\nKenshi hereby restricts you from all of the following:\nRepublishing any Kenshi content in any media;\nReproducing, duplicating, or copying any Kenshi content;\nSelling, renting, sublicensing, and otherwise commercializing any Kenshi content;\nPublicly performing or displaying any Kenshi content;\nUsing this Website in a manner that is, or maybe, damaging or impacts user access to this Website;\nUsing this Website contrary to the relevant rules, laws, and regulations of your country of residence\nor in a manner that causes, or may cause, harm to the Website or any person or business entity;\nConducting data mining or any other similar activity concerning this Website or while using this Website; and\nUsing this Website to engage in any form of business advertising or marketing.\nSpecific areas of this Website may be restricted from user access, and Kenshi may further extend the restriction\nto the entire Website at any time and at its sole discretion. Any user identification, security key, or password\nyou may have on this Website is confidential, and you are responsible for maintaining such information confidentiality.\nWe reserve the right to file requests that you remove all links or any particular link created by you that\nredirect to our Website and you approve of removing such links to our Website upon request immediately.\nWe may amend the terms and conditions of these linking rights at any time. By continuously linking to our\nWebsite, you agree to be bound to and follow the terms of this linking policy.\nFeel free to contact us if you find any offensive links on our website, and we may consider requests to\nremove such links. Still, we are not obligated to do so or respond to you directly or immediately.\nOrganizations such as search engines, government agencies, news organizations, and online directories may\nlink to our Website without prior written approval. We may review other link requests from popular consumer\nor information specialists, charity organizations, internet portals, educational institutions, trade associations,\nand dot.com community sites. Any interested organization must inform and contact us for further information\nregarding our linking policy. However, such linking does not imply endorsement, sponsorship, partnership,\nor approval by us.\nNo use of our logo or other design intellectual property will be allowed for linking except a trademark\nlicense agreement.\nThis Website may contain links to websites or applications operated by third parties. Please know that we\ndo not control any such third-party websites or applications or third-party operator. Kenshi is not\nresponsible for and does not endorse third-party websites or applications or their availability or content.\nKenshi accepts no responsibility for adverts contained on the Website. You agree to do so at your own\nrisk when purchasing any goods or services from any such third party. The advertiser, and not us, remains\nresponsible for such goods or services, and if you have any questions or complaints about them, you should\ncontact the advertiser.\nIn these Website Standard Terms and Conditions, \"User Content\" shall mean any audio, video, text, images,\nor other material or content you choose to display on this Website. Concerning user content, by displaying\nit, you grant Kenshi a non-exclusive, worldwide, irrevocable, royalty-free, sub-licensable license to use,\nreproduce, adapt, publish, translate and distribute it on any media.\nUser Content must be your own and not infringe on any third party's rights. Kenshi reserves the right to\nremove any of your content from this Website at any time without notice.\nKenshi is permitted to monitor your activities on the Website and remove any user content considered\ninappropriate, offensive, contrary to applicable laws and regulations, or causes a breach of these\nTerms and Conditions.\nYou warrant and represent that:\nYou are entitled to upload/input/publicize content on our Website and have the necessary\nlegal capacity, license, or consent to do so;\nYour content does not infringe any intellectual property right, including without limitation\nto copyright, patent, or trademark of any third party;\nYour content is true, accurate, current, complete, and relates to you and not a third party;\nYour content does not contain any libelous, defamatory, offensive, immoral, or otherwise illegal\nmaterial, which is an invasion of privacy; and\nThe content will not be used to solicit or promote business or custom or present commercial\nactivities or unlawful activity.\nYou hereby grant Kenshi a non-exclusive license to use, reproduce, edit and authorize others approved by\nus to use, reproduce and edit any of your content in any form, format, or media.\nUsing this Website and its services may provide us with certain personal information. By using Kenshi\nor its services, you authorize us to use your information in any country or state in which we operate\nin. We reserve the right to use such information to improve your user experience and facilitate mailing,\ntraffic, and market analytics.\nBy accessing this Website, specific information about the User, such as Internet protocol (IP) addresses,\nsite navigation, user software, and surfing time, along with other similar information, will be stored on\nKenshi servers. Information about their identities, such as name, address, contact details, billing\ninformation, and other information stored on this Website, will strictly be used for statistical purposes\nand will not be published for general access. Kenshi, however, assumes no responsibility for the security\nof this information.\nKenshi Website is provided \"as is,\" with all liabilities, and Kenshi makes no express or implied undertakings,\nrepresentations, or warranties, of any kind related to this Website or the content contained on this Website.\nKenshi does not make any endorsements, warranties, or representations about any such content's accuracy,\nreliability, expertise, or completeness. You agree that reliance on such content shall be at the User's risk.\nThe Kenshi periodically changes, adds, modifies, improves, or updates this Website's consent with or without\nprior notice. Under no circumstance shall Kenshi be liable for any loss, damage, injury, liability, or expense\nincurred or suffered from the use of this Website, including, without limitation, any fault, error, omission,\ncommission, delay, failure, interruption, deletion, alteration, disruption, cessation or incursion concerning\nsuch use by us, our affiliates or any third party. Under no circumstance shall Kenshi or any of its partners\nand affiliates be liable for any direct, indirect, consequential, accidental, or special damages, even if Kenshi\nhas been advised against the risk or possibility of such damages. The User agrees that Kenshi will not be liable\nfor any conduct or behavior of the User arising from the use of this Website. As a result, using this Website\nand all or any of its content is at the User's sole risk.\nIn no event shall Kenshi, nor any of its officers, directors, employees, and affiliates, be liable for any loss,\ninjury, or damage arising out of your use of this Website, whether under contract, tort, or otherwise, and Kenshi,\nincluding its officers, directors, employees, and affiliates shall not be liable for any indirect, consequential\nor special liability arising out of your use of this Website.\nAs a condition for the use of this Website, the User agrees to indemnify Kenshi and its affiliates to\nthe fullest extent, from and against all actions, claims, liabilities, losses, damages, costs, demands,\nand expenses (including reasonable attorney's fees) arising out of the User's use of this Website,\nincluding without limitation, any claim related to the breach of any of the provisions of these Terms\nand Conditions. If dissatisfied with any or all of the content on this Website or any or all of its Terms\nand Conditions, the User may discontinue using this Website.\nThe provisions of these Terms and Conditions shall remain in full force and effect while you use Kenshi\nor its services. Users may terminate their use by following the instructions for terminating user accounts\nin your account settings or contacting us at support@kenshi.io.\nWe reserve the right and sole discretion to, and without notice or liability, deny access to and use of\nthe Website (including blocking specific IP addresses) to any user for any reason, including but not\nlimited to breach of any representation, warranty, or Agreement in these Terms or any applicable law or\nregulation.\nWe also reserve the right, if, in our sole discretion, we determine that your use of the Website or its\nservices is in breach of these Terms and Conditions or of any applicable law or regulation, to terminate\nyour use of the Website and its services or delete your account and any or all of your content, without\nwarning or prior notice. Suppose we terminate or suspend your account for any reason under this section.\nIn that case, you are prohibited from registering and creating a new account under your name, a false\nidentity, or the expression of a third party. In addition to terminating or suspending your account,\nKenshi reserves the right to take appropriate legal action(s), including pursuing civil, criminal, and\ninjunctive redress without limitation.\nAll correspondence made under this Agreement shall be in English.\nThe Terms and Conditions of this Website will be governed by and construed under the laws of the country\nor state where Kenshi operates. You hereby unconditionally submit to the non-exclusive jurisdiction of the\nVaud, Switzerland courts for the resolution of any disputes.\nSuppose any terms or conditions are proven unenforceable or void under applicable law. In that case,\nsuch shall not render these Terms and Conditions unenforceable or invalid. As a result, any such\nprovision shall be deleted without affecting the remaining provisions herein. The provisions of these\nTerms and Conditions that are unlawful, void, or unenforceable are deemed severable from these Terms\nand Conditions and do not affect any remaining provisions' validity and enforceability.\nKenshi reserves the right to revise these Terms whenever it sees fit. By using Kenshi, you are expected\nto review such Terms regularly to ensure you comprehend all the Terms and Conditions regarding using this\nWebsite.\nKenshi reserves the right to assign, transfer, and subcontract its rights or obligations under this Agreement\nwithout any prior notification or consent required. Users shall not be permitted to assign, transfer, or\nsubcontract any of your rights and obligations under these Terms. Furthermore, a person not a party to these\nTerms and Conditions shall have no right to enforce any provision.\nNothing herein shall constitute a limitation upon the privileges and immunities of Kenshi, which are\nspecifically reserved.\nOur failure to exercise any or all of these Terms and Conditions provisions at any time shall not operate as\na waiver of such right or provision.\nThese Terms and Conditions, including any legal notices and disclaimers on this Website, constitute the\nentire Agreement between Kenshi and you concerning your use of this Website. Ultimately, this Agreement\nsupersedes all prior agreements and understandings concerning the same.\nTo resolve any complaint or clarification regarding the use of this Website or its services or receive\ninformation concerning that, please contact us at support@kenshi.io.",
    "breadcrumb": [
      {
        "url": "/docs",
        "title": "Documentation"
      },
      {
        "url": "/docs/terms-and-conditions",
        "title": "Terms and Conditions"
      }
    ]
  },
  {
    "text": "Kenshi is a Swiss-based blockchain company offering services such as\nCustom Oracle Network,\nblockchain IoT SDK,\nDeep Indexing,\nGraphQL, and\nReverse-API (webhooks)\non Ethereum, Arbitrum, Aurora, Avalanche, Fantom, Polygon, Bitgert and the BNB Smart Chain.\nBuying the token? Make sure you read the token documentation first.\nWhat is Kenshi?\nUnchained\nServices and Products\nThe Kenshi token\nTeam\nRoadmap\nPuzzles\nCommunity\nTech Stack\nFAQ\nMedia\nReferral program\nTerms and Conditions",
    "breadcrumb": [
      {
        "url": "/docs",
        "title": "Documentation"
      }
    ]
  },
  {
    "text": "Kenshi Analytics offers a fully-featured dashboard for visualizing\nyour smart contract data.\nThis page is a work in progress.",
    "breadcrumb": [
      {
        "url": "/docs",
        "title": "Documentation"
      },
      {
        "url": "/docs/services",
        "title": "Services and Products"
      },
      {
        "url": "/docs/services/deep-index",
        "title": "Deep Index"
      },
      {
        "url": "/docs/services/deep-index/analytics",
        "title": "Analytics for Deep Index"
      }
    ]
  }
]