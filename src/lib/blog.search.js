export default [
  {
    "text": "When a new technology emerges and finds its early adopters, some people, and organizations\nquickly become household names. They find avid fans ready to yell at everyone about the\ngreatness of their favorite person or project. Blockchain technology has followed the same\ntrajectory, especially regarding the best blockchains for building a decentralized app.\nAll the arguments about the best blockchains, further obscured by the arguments about\nthe best cryptocurrencies, need to be clarified for many beginner developers. That's why\ntoday, we will list the best blockchains for building a decentralized app (dApp).\nSo if you want to become a web3 developer and start building on a blockchain, stick around\ntill the end. And who knows? Your project may have avid fans of its own someday.\nRegarding the best blockchains for building a decentralized app (dApp), no list will be\ncomplete without Ethereum. From its launch (in 2015) till 2021, it was the only reasonable\noption for building dApps and creating smart contracts.\nNow it has serious competition, but many competitors also use EVM or Ethereum Virtual Machine.\nYou can say that Ethereum paved the way for what we see in the industry today. The native\nprogramming language for the Ethereum blockchain is Solidity, and the native coin for the\nnetwork is called Ether (eth).\nEthereum was a proof-of-work blockchain like Bitcoin, but it has started using proof of\nstake as its consensus mechanism; this is part of the upgrade from Ethereum 1.0 to Ethereum 2.0,\nwhich will also bring sharding to this network in the near future.\nPros:\nDetailed documentations\nBiggest community of builders\nBig decentralized network of nodes (which means better security)\nYou can build on Ethereum and deploy on other EVM chains as well (with minor changes)\nCons:\nGas fees can be high right now\nWith lots of users and no sharding yet, it's not very scalable unless you use a layer2\nblockchain (transactions can be slow right now)\nBinance was already one of the biggest crypto exchanges when it built its blockchain.\nFirst, they created the \"Binance Chain\" to handle large amounts of data quickly.\nThis blockchain was dApp compatible but mainly focused on Binance's needs\n(i.e., trading cryptocurrencies). So when they decided to attract more developers and\ncompanies to their ecosystem, a second blockchain was born. This one supported smart\ncontracts. It was also EVM compatible.\nLater, Binance rebranded the Binance Chain as the \"Beacon Chain\" or \"BC\" and renamed\nBinance Smart Chain to \"BNB Smart Chain\" or \"BSC.\" Now, they run parallel with a\nthird blockchain called the \"Sidechain.\"\nThese three blockchains have different purposes and use different standards, but\nthey work together to make the BNB Chain. Beacon Chain is the governance arm of\nthe BNB Chain. Sidechain allows developers to create and run their blockchains,\nand Binance Smart Chain is where you'll build your dApps and smart contracts.\nPros:\nEVM compatible\nBig community\nFast transactions\nLow gas fees\nIncentives and programs for developers (backed by Binance)\nBinance Bridge allows users to move assets to and from BNB Chain easily\nCons:\nMore centralized than some other blockchains\nMost innovations happen on Ethereum and then arrive on BSC\nAvalanche is another EVM-compatible blockchain with a unique proof of stake consensus\nmechanism. In a regular proof of work or proof of stake, when most nodes agree on something,\nit becomes the new state of the blockchain.\nBut in Avalanche, not all nodes are asked about every transaction. Instead, random nodes\nare asked about their opinion on a transaction, and when a certain number is reached,\nit becomes the new state of the blockchain. This method allows Avalanche to be extremely\nfast and low-cost.\nAlso, Avalanche is three blockchains working together. One is the Platform Chain, the\nother is the Contract Chain, and the last is the Exchange Chain. These three blockchains\nare secured and validated by all the Avalanche validators. There are also sovereign networks\ncalled subnets, which can have their own rules. Subnets make Avalanche entirely scalable.\nPros:\nEVM compatible\nBlazing Fast\nLow gas fees\nInnovative new network with high potential\nCan become truly decentralized\nHigher security with a unique consensus mechanism (instead of 51%, an attack on Avalanche will need 88% to take control of the whole network)\nIncentives for web3 builders\nEco friendly\nCons:\nAvalanche Bridge only supports asset transfer between Avalanche and Ethereum right now\nThere are no defined punishments for bad actors and malicious nodes (no slashing can be\nconsidered reasonable in some scenarios, but it increases the overall risk for network\nparticipants)\nPolygon (formerly called Matic) started as a solution to Ethereum's scaling problem.\nTheir main objective was lower gas fees and faster transactions, compared to Ethereum,\nwithout sacrificing security; Polygon does this using a sidechain or a layer two blockchain.\nHowever, Polygon is developing other solutions as well. So if you like Ethereum but hate its\noccasional high gas fees and slow transactions, Polygon can be your choice.\nPros:\nLow cost\nFast transactions\nBuilt by developers for developers (offers many valuable tools)\nBig community of builders\nA large number of active dApps and games\nMany partnerships and acquisitions\nPolygon Bridge works well with assets that sit on Ethereum\nCons:\nIts first chain is more centralized than Ethereum\nWith Ethereum 2.0, some of Polygons's solutions may become obsolete over time\nCardano is a unique project. It tries to solve real problems and create positive changes in\na very systematic and academic way. Cardano is built to be scalable, sustainable, and\ninteroperable with other blockchains.\nCardano has created a unique protocol called \"Ouroboros\" to make its blockchain scalable\nand truly decentralized. It uses proof of stake for sustainability and allows everyone to\neasily stake their \"ADA\" (Cardano's native cryptocurrency) by delegating power to a pool.\nFinally, Cardano is building bridges between itself and other blockchains for\ninteroperability. There are few bridges available right now, but more are under development.\nCardano is written in a programming language called Haskell, but you can build dApps and\ncreate smart contracts using many other languages on this blockchain.\nPros:\nHuge community\nMany prestigious partnerships\nVery academic and methodical\nIt has special programs for investing in innovative ideas to be built on Cardano\nCons:\nMany features are still under development\nNot EVM compatible\nADA's price doesn't accurately reflect Cardano's strong fundamentals\nFantom is a network of blockchains with a focus on speed and scalability. It uses a consensus\nmechanism called \"Lachesis,\" a unique proof of stake that makes the network ultra-fast and secure.\nMost Blockchains offer incentives to regular users at their start, but Fantom tried a different\napproach and made a massive investment to get more developers building on its network. The result\nwas many dApps and games that brought many users and die-hard fans to the Fantom ecosystem.\nPros:\nGreat marketing and branding\nMany incentives for developers\nVibrant community\nEVM compatible\nVery fast\nCons:\nMore centralized than some other blockchains\nLike many other blockchains that try to offer an alternative to Ethereum, Solana has built a\nfast and cheap network, but unlike many others, they didn't do it by copying Ethereum's\ncode. That's why Solana isn't EVM-compatible.\nThey use proof of history, another version of proof of stake, to make transactions fast and the\nwhole process of building blocks very efficient. Another innovation that helps with this\nefficiency is called \"Sealevel\" runtime, a fancy term for saying that validators or nodes can\nrun multiple smart contracts simultaneously.\nSolana uses the Rust programming language, which allows developers to create more complex smart\ncontracts and dApps.\nPros:\nExtremely fast and cheap\nBig community\nOffers grants to innovative projects\nCons:\nMore centralized than some other blockchains\nNot EVM compatible\nHas experienced downtimes on different occasions\nArbitrum is the biggest layer2, proof of stake blockchain, built on Ethereum.\nUnlike any other blockchain on this list, it doesn't have a native coin.\n(It probably will in the future.) So you pay gas fees using ETH. These fees are much\nlower on Arbitrum because of its high throughput compared to Ethereum.\nWe should also note that Arbitrum has two separate networks. The main network\nthat most people use for DeFi (Decentralized Finance) and smart contracts is\nArbitrum One. You can also build on Arbitrum Nova which is faster and cheaper.\nThe main difference is that Arbitrum One always puts transaction data on the\nEthereum blockchain. However, Nova uses \"the committee\" to finalize transactions\nand falls back on Ethereum only if the committee fails. Without getting into more\ndetails, this makes Arbitrum Nova an ideal choice for building games or reward\nsystems like Reddit.\nPros:\nEVM compatible but also supports other programming languages like Rust\nOne of the fastest-growing ecosystems (especially for DeFi)\nFaster and cheaper than Ethereum without sacrificing security\nCons:\nArbitrum's bridge takes a week to transfer your funds from other blockchains\nIt doesn't have its coin yet\nThere is no one best blockchain for building a dApp. So if you ask, \"what is the best blockchain?\"\nwe have to answer with a big \"it depends.\"\nIf you're a beginner looking to start with web3 and blockchain technology, you should go for one\nof the more famous names (anyone on our list will do). If you want to change blockchains easily\nin the future, consider EVM-compatible ones.\nOther than that, for the more experienced developers, you should define your project clearly\nand list the features you need to build and maintain it. Only then can you choose the best\nblockchain for building your dApp.\nGo to the Kenshi dashboard and connect your wallet to get started with Kenshi's tools for all\nEVM-compatible blockchains. Begin building with Kenshi today!",
    "breadcrumb": [
      {
        "url": "/blog",
        "title": "Blog"
      },
      {
        "url": "/blog/best-blockchains-for-building-a-decentralized-app",
        "title": "Best Blockchains for Building a Decentralized App"
      }
    ]
  },
  {
    "text": "If you want to be a blockchain developer or just an informed web3 user, you should\nknow that data is stored differently on a blockchain. Because of this, querying\nblockchain data is a lot harder than querying a standard database on a web2 server.\nIn this post, we'll tell you why this is, and we'll explain a new method to query\nblockchain data. So stay around if you want to know more.\nIn the case of regular apps, when the app lets people create accounts or any content,\nit needs a fast and secure database that the app can query. dApps are similar in this regard.\nThe only difference is that dApps use blockchains as a primary database, and blockchains\nare hard to query. So if you want your dApp to be fast and function properly, you'll\nneed to build a secondary database yourself.\nLet's see some examples:\nIf you want to build a decentralized exchange (DEX) that shows the real-time amount\nof liquidity for every trading pair or biggest liquidity providers and other similar\ndata, you'll need a secondary database to store indexed blockchain data.\nIf you want to build a betting dApp, you need to be able to take users' bets and reward\nthe winners when the outcome gets determined. To do this fast, you need a database for all\nthe bets you can query to find the winners.\n(In this example, you must also use Oracles to generate randomness or get real-world data\nto your dApp. We recommend using Kenshi Oracles.)\nIf you want to build a rating or review system within your dApp or blockchain game,\nyou need to take in the ratings from different users. These ratings are initially stored\non the blockchain, but you will need a database if you want to display an accurate and\nlive aggregate of these reviews.\nIf your dApp has a governance token that determines users' voting power, you'll need\na database of all user addresses and the number of tokens each user holds. This database\nneeds to be extremely fast, and you need to be able to query it before every vote.\nThese are just some of the use cases for indexed blockchain data today. Blockchain data\nindexing is a relatively new technology, and new use cases will emerge. You'll find a\nnew use case yourself when building your dApp!\nSome things will change as we gradually move from a centralized web2 to a decentralized web3.\nFor example, ordinary users will have more autonomy over their data because everything will\nbe on a peer-to-peer (p2p) network and not on centralized servers owned by a few companies.\nHowever, these kinds of decentralized networks come with their own difficulties and\ncomplications. For example, when you want to access a file on web2, you give its address\n(URL) to your browser; this is location-based addressing.\nBut in blockchains, we have content-based addressing. So if you want to access something\non a blockchain, you don't request its location. Instead, you directly ask what you're\nlooking for, which might be spread across many nodes.\nThis process makes everything more secure. But simultaneously, it makes querying data and\noperations like search and aggregation very difficult. For example, how long will it take\nfor a dApp running on a browser to process every event emitted by a smart contract and then\naggregate the data to make it usable? That's why we need a new solution to query blockchain\ndata.\nYou can use your servers and process the data you need over there. Then, you can organize\nit into a database and build an API endpoint to query the data for your dApp. But this\nmethod is not recommended. Because it will:\nCreate a single point of failure for your dApp\nMake everything less decentralized and less secure:\nCost a lot to maintain as your dApp grows\nYou'll spend a lot of money to build a database, and if you make any mistakes, your\nwhole dApp will be highly vulnerable.\nIf you're looking for a simple and easy way to query blockchain data, you should try Kenshi's\nDeep Index service. You can retrieve, index, and store the needed data using \"Sync.\" Instead\nof your servers, you'll use Kenshi's Data Clusters.\nThen, you can use MQL or GraphQL to query the stored data and get the desired results via\nKenshi's query endpoints to your dApp. You can also use Reverse-API (Webhooks) to get\nnotifications about specific blockchain events.\nWe think Kenshi's Deep Index is the superior option for indexing and querying a blockchain\nbecause:\nIt's a fully managed service that is built by experts\nIt can keep up with your dApps, no matter how much they grow\nIt's fast and secure\nIt doesn't cost that much, especially when you're just getting started\nAs you can see, using Kenshi's Deep Index services has many benefits. It's a reliable service\nthat can grow with your dApp and stay cost-effective. So if you need to index and query\nblockchain data, this is your best bet.\nTo start with Kenshi's Deep Index services, connect your wallet to the Kenshi\nKenshi dashboard.\nYou can also read our documentation for this\nservice to learn more.\nStart building with Kenshi today!",
    "breadcrumb": [
      {
        "url": "/blog",
        "title": "Blog"
      },
      {
        "url": "/blog/how-to-access-and-query-blockchain-data",
        "title": "How to Access and Query Blockchain Data"
      }
    ]
  },
  {
    "text": "A blockchain VRF (Verifiable Random Function) oracle is a mechanism that generates random\nnumbers on a blockchain network in a verifiable and tamper-proof way. You can use VRF oracles\nto generate random numbers for various purposes, such as smart contract-based lottery games,\ndecentralized exchanges, and other dApps that require a random number generator.\nThe need for a VRF oracle arises from the fact that a blockchain is an immutable and decentralized\nsystem. As such, it is impossible to generate truly random numbers on a blockchain without using an\nexternal source of entropy. VRF oracles solve this problem by generating random numbers that can be\nverified and audited by all parties on the blockchain network; this ensures that the random numbers\ngenerated are genuinely random and not influenced by any single party.\nA dedicated VRF (Verifiable Random Function) oracle has several benefits compared to one that\nshares its private key with many others:\nSecurity:  A dedicated VRF oracle reduces the risk of key compromise as only one\nparty uses the private key by one party rather than being shared among multiple parties.\nIf a shared VRF oracle's private key is compromised, all parties utilizing the oracle are\naffected.\nPrivacy:  A dedicated VRF oracle can generate unique and private random numbers for\neach party using it, preventing any potential cross-contamination of information.\nCustomizability:  With a dedicated VRF oracle, the party using it has complete control\nover the oracle and can configure it to meet their specific needs. This level of customizability\nallows the party to tailor the oracle to their particular use case, such as generating random\nnumbers for specific algorithms or protocols.\nPerformance:  A dedicated VRF oracle can have its dedicated resources, ensuring it\nis always available and responsive to requests. Dedicated resources can result in faster\nresponse times and higher throughput, especially for high-traffic applications.\nTrust:  By having a dedicated VRF oracle, the party using it can have greater trust\nin the oracle's security and the integrity of the generated random numbers.\nCompliance:  In some cases, regulations or industry standards may require using a\ndedicated VRF oracle to ensure that the generated random numbers meet specific requirements.\nFor example, in the financial industry, regulations such as PCI DSS and HIPAA require specific\nsecurity controls to be in place. Using a dedicated VRF oracle can help financial institutions\nmeet these requirements by ensuring the integrity and security of the generated random numbers.\nCost-effectiveness:  Depending on the scale of the application, using a dedicated VRF\noracle may be more cost-effective in the long run, as it allows for greater control over the\noracle and reduces the risk of key compromise.\nOrganizations in various industries should consider using a dedicated VRF oracle to ensure that\nthe generated random numbers meet specific security, integrity, and fairness requirements and\ncomply with regulatory standards.\nIn this article, we will show you how to make your dedicated VRF oracle using the Kenshi Oracle\nNetwork.\nTo create your custom oracle with the Oracle Network, you can use your preferred programming language.\nIn this tutorial we will use JavaScript. We will also write a sample smart contract in Solidity\nthat will interact with your new oracle. I will show you how to code, create and deploy your\ndedicated VRF oracle and guide you through the best security practices.\nThis tutorial uses the Kenshi VRF library for generating randomness. This library implements\nthe 10th draft of ECVRF published\nby the IETF. I will use Vercel to deploy the oracle, but you can host it anywhere else. To\nfollow this tutorial, you can create a free Vercel account.\nThe first thing you need is to set up your project tree. Run the following commands to\ncreate a npm project and install the required dependencies:\nYour oracle needs a private key for to generate secure randomness using the VRF. We can\nuse the Kenshi VRF library to get one. Let's write a few lines of code in \"misc/keys.js\" that\nprints out a key pair when executed:\nSave and run the above file with Node and you'll have your private key and its corresponding\npublic key. Write these down in a safe place as we'll need them later. Usually you should\nstore these in a secret manager and read them only when needed. However, to keep this tutorial\nsimple we won't cover that step. Instead we will just use Vercel environment variables to\nstore the private key.\nKeep your private key safe. If you want to let third-parties verify the randomness\ngenerated by your oracle, all you need is to share the public key.\nYour oracle logic should go to the \"api/oracle.js\" file. You need a function that\ntakes in the information about a randomness request and generates randomness from it.\nThis function should also generate the required parameters for verifying the randomness\non chain.\nYou should never use a non-cryptographic RNG over a Verifiable Random Function. If you do,\nyour oracle will be vulnerable to attacks and manipulations. Furthermore, the generated\nrandomness won't be verifiable and you won't be able to prove its fairness.\nHere's a sample function that takes in a transaction and generates randomness from it,\ntogether with the parameters required for verifying it on-chain using the Kenshi VRF library:\nWe encourage going through the\nECVRF draft published by\nthe IETF once to better understand the concepts mentioned in this article.\nYou also need to implement the Kenshi Oracle Network protocol. You only need a simple HTTP\nserver that tells the Oracle Network what to do with the incoming request. You need to tell\nthe Oracle network which function on your smart contract it should call, what arguments it\nshould pass to the function, and how much gas it is allowed to spend.\nUsing Vercel, you can do the following to achieve this:\nTo deploy the oracle, you can run this command at the root of the project and follow\nthe instructions:\nYou should see an output like this:\nCopy and keep the deployment URL safe, as you will need it later. You need one more step to make\nthe project functional. You need to go to the Vercel dashboard, find your project, and enter your\nprivate key as the value for the \"VRF_PRIVATE_KEY\" environment variable:\nNow you need a smart contract that talks to your oracle and requests randomness, so let's make\na simple contract that does just that. Let's create a barebone contract first:\nNow you need a function that emits an event requesting the randomness. Let's add this function\nand the corresponding event:\nNext you will need a callback function that your oracle will call to deliver the requested randomness.\nYou contract should also emit an event that shows what random number was delivered. Since you want to\nverify the delivered randomness on-chain, you need to accept a few specific parameters and pass them\nto the Kenshi VRF libraries verification function:\nLet's add some security to the contract and verify that your oracle, not an attacker, is\ncalling your callback. You also want to prevent double delivery of randomness by keeping\ntrack of each request:\nYou can now head over to Remix IDE and deploy the above smart contract. You should pass\nthe public key you generated to the constructor function of the smart contract, don't forget\nto prefix it with 0x:\nCopy the deployed contract address and the block number in which you deployed the contract\nsomewhere safe, as you will need them later.\nYou're now ready to create your oracle on the Kenshi Oracle Network. Head to the Kenshi Oracle Network\ndashboard and click the \"Create Oracle\" button. Fill out the form as follows:\nSelect your smart contract chain (BNB Smart Chain for this example) from the \"Blockchain\"\ndropdown and input your deployed contract address in the \"Contract address\" field.\nEnter the block number of your smart contract into the \"Block\" field under the \"Starting point\"\nsection. This field tells the Oracle Network to look for randomness requests starting from that\nblock.\nIn the \"Endpoint\" field under the \"Oracle logic\" section, enter the deployment address you\ngot from Vercel.\nInput the human-readable ABI of your contract into the form's \"ABI\" field.\nEnter the event signature defined in your smart contract into the \"Signature\" field.\nFinally, you can decide on how many months and for how many requests the Oracle Network\nshould keep your oracle alive.\nThe filled form should look similar to this, except for the contract address and the oracle\nlogic endpoint:\nOnce deployed, go to the oracle admin page on the Kenshi Oracle Network dashboard and copy\nthe gas (sender) address of your oracle from the \"Add Credit\" tab:\nYou need to transfer a little bit of gas to your oracle so it can fulfill randomness requests:\nAnd finally, you will need to authorize the oracle address in your smart contract:\nNow you can call the \"requestRandomness\" function of the contract, and assuming you followed\nall the previous steps, the oracle should send you a response:\nYou should be able to see the delivered randomness now:\nIn this article we demonstrated a simple VRF oracle, however the possibilities of\nthe Kenshi Oracle Network are limitless! Be sure to follow us on Twitter if you want more\nnews about Kenshi or more awesome articles about the Kenshi Oracle Network.\nYou can view the source code of this sample oracle\nhere on GitHub.",
    "breadcrumb": [
      {
        "url": "/blog",
        "title": "Blog"
      },
      {
        "url": "/blog/how-to-create-a-vrf-oracle-using-the-kenshi-oracle-network",
        "title": "How to create a VRF oracle using the Kenshi Oracle Network"
      }
    ]
  },
  {
    "text": "UniSwap is a leading decentralized cryptocurrency exchange (DEX) that operates\non the Ethereum blockchain. It uses an automated market-making (AMM) model,\nallowing users to trade tokens without needing an order book or centralized\nintermediaries. Users can earn a share of trading fees by providing liquidity to\nthe platform. UniSwap has played a significant role in the growth of the\ndecentralized finance (DeFi) ecosystem and continues to be a popular choice for\ntraders and developers alike.\nKenshi Deep Index provides a robust and easy-to-use platform for indexing\nblockchain events, such as those on the popular decentralized exchange, UniSwap.\nFor just $15, users can index about one million events and run thousands of\nqueries per month. The geographically distributed indexed data ensures high\navailability and fast access times. This tutorial will guide you through\nindexing UniSwap events using the Kenshi Deep Index Sync task service. Following\nthese steps, you can query UniSwap events via the Kenshi GraphQL API or set up\nwebhooks to receive notifications when events occur.\nBefore diving into the tutorial, please make sure you have the following:\nAccess to the Kenshi dashboard\nA connected wallet\nThe UniSwap contract address and ABI\nGo to the Kenshi dashboard and connect your wallet.\nClick on the \"New Sync Task\" button to open the \"New Deep Indexing Task\" form.\nFollow these guidelines to fill in the form with the relevant information for UniSwap:\nChain:  Select the appropriate chain where the UniSwap data is. For example,\nif you want to index events from UniSwap deployed on the Ethereum Mainnet, choose\n\"Ethereum\" from the dropdown menu.\nStarting block:  Input the block number from which you want to start syncing\nevents. For UniSwap, you should input the block number at which the UniSwap contract\nis deployed or from which you want to start indexing.\nContract address:  Provide the UniSwap contract address as the source of events.\nThe contract address for the UniSwap router on Ethereum is\n.\nContract ABI:  Input the ABI (Application Binary Interface) of the UniSwap smart\ncontract. You can either input the entire ABI or include only the ABI of the events\nyou are interested in. The ABI can be in Human-Readable ABI or the JSON format emitted\nby the Solidity compiler. You can use\nto index  events.\nStorage:  Choose how much storage you need for storing these events. You can\nchoose a value between 100MB to 400GB. Each 100MB of storage can hold about 350,000 events.\nFrequency:  Choose at which frequency you would like to index the events. If\nyou need real-time data, choose Instant. Otherwise, you can select a small delay to\nsave on indexing costs.\nDuration:  Define the duration for which the service should run in months.\nOnce you have filled in the form with the correct information, click the\n\"Submit\" button to create the Sync task. The Kenshi Deep Index Sync task service\nwill fetch UniSwap events and store them in the Kenshi blockchain data clusters\nfor you to query or receive notifications.\nNow that you have set up the Kenshi Deep Index Sync task and indexed the UniSwap\nevents, it's time to query the data using the Kenshi GraphQL service.\nObtain an API key:  Visit the Kenshi dashboard, connect your wallet, fill out and\nsubmit the \"New GraphQL + MQL API Key\" form. Make sure to choose an appropriate\nnumber of requests for your needs. Remember that each successful or unsuccessful\ncall counts as one usage.\nUse a GraphQL library or make an HTTP POST request:  To interact with the Kenshi\nDeep Index GraphQL endpoint, you can either use a GraphQL library for your\npreferred programming language or make an HTTP POST request directly to the\nendpoint. The endpoint address and examples for making GraphQL requests can be\nfound in the Kenshi documentation.\nUse the provided schema:  Kenshi documentation provides the schema for making\nrequests to the GraphQL endpoint and for returned data types. This schema can be\nused in languages like Go, where an interface is required for unpacking the\nreceived GraphQL data.\nWith these steps, you can query the indexed UniSwap events and analyze the data\nas needed. Remember to consult the Kenshi documentation for more information on\nusing the dashboard and understanding the Sync service. Here's a sample code to\nget you started with Node.js:\nCongratulations! You have successfully created a Kenshi Deep Index Sync task to\nindex UniSwap events. You can now use the Kenshi GraphQL or MQL API to query the\nindexed data or set up the Kenshi Reverse-API (Webhooks) service to receive\nevent notifications. Remember to check the Kenshi documentation\nfor more information on using the dashboard and understanding the Sync service.",
    "breadcrumb": [
      {
        "url": "/blog",
        "title": "Blog"
      },
      {
        "url": "/blog/how-to-index-uniswap-events-using-kenshi-deep-index",
        "title": "How to Index UniSwap Events Using Kenshi Deep Index"
      }
    ]
  },
  {
    "text": "Are you looking for a flexible, scalable and affordable solution for getting token prices\non chain? In this article we will show you how to can make your own dedicated price feed\noracle using the Kenshi Oracle Network.\nTo create your custom oracle with the Oracle Network, you can use your preferred programming language.\nIn this tutorial we will use JavaScript. We will also write a sample smart contract in Solidity\nthat will interact with your new oracle. I will show you how to code, create and deploy your price\nfeed oracle and guide you through the best security practices.\nThis tutorial uses the CoinGecko APIs for getting the token prices, but you can use any\nother API as you see fit. I will also use Vercel to deploy the oracle, but you can host\nit anywhere else. To follow this tutorial, you can create a free Vercel account.\nFirst you will need a smart contract that talks to your oracle and requests price data, so let's make\na simple contract that does just that. Let's create a barebone contract first:\nNow you need a function that emits an event requesting the price data. Let's add this function\nand the corresponding event:\nNext you will need a callback function that your oracle will call to deliver the requested price data,\nand another function to show the price once it is delivered:\nLet's add some security to the contract and verify that your oracle, not an attacker, is\ncalling your callback:\nYou can now head over to Remix IDE and deploy the above smart contract:\nCopy the deployed contract address and the block number where we deployed the contract\nsomewhere safe, as you will need them later.\nThe first thing you need is to set up your project tree. Run the following commands to\ncreate a npm project and install the required dependencies:\nYour oracle logic should go to the \"api/oracle.js\" file. Now you need a function that\nfetches the token price you are interested in from CoinGecko API endpoints. In this\nfunction, you want to get an average price of your token.\nYou could also use the spot price of the token, but that would make your oracle vulnerable\nto price manipulation attacks. For example, an attacker could create a transaction to change\nthe token price in their favor, interact with your oracle, benefit, and finally make another\ntransaction to revert the token price to its original value.\nHere's a sample function that fetches price data for the Kenshi token and calculates its\n30-minute average:\nYou also need to implement the Kenshi Oracle Network protocol. You only need a simple HTTP\nserver that tells the Oracle Network what to do with the incoming request. You need to tell\nthe Oracle network which function on your smart contract it should call, what arguments it\nshould pass to the function, and how much gas it is allowed to spend.\nUsing Vercel, you can do the following to achieve this:\nTo deploy the oracle, you can run this command at the root of the project and follow\nthe instructions:\nYou should see an output like this:\nCopy and keep the deployment URL safe, as you will need it later.\nYou're now ready to create your oracle on the Kenshi Oracle Network. Head to the Kenshi Oracle Network\ndashboard and click the \"Create Oracle\" button. Fill out the form as follows:\nSelect your smart contract chain (BNB Smart Chain for this example) from the \"Blockchain\"\ndropdown and input your deployed contract address in the \"Contract address\" field.\nEnter the block number of your smart contract into the \"Block\" field under the \"Starting point\"\nsection. This field tells the Oracle Network to look for price data requests starting from that\nblock.\nIn the \"Endpoint\" field under the \"Oracle logic\" section, enter the deployment address you\ngot from Vercel.\nInput the human-readable ABI of your contract into the form's \"ABI\" field.\nEnter the event signature defined in your smart contract into the \"Signature\" field.\nFinally, you can decide on how many months and for how many requests the Oracle Network\nshould keep your oracle alive.\nThe filled form should look similar to this, except for the contract address and the oracle\nlogic endpoint:\nOnce deployed, go to the oracle admin page on the Kenshi Oracle Network dashboard and copy\nthe gas (sender) address of your oracle from the \"Add Credit\" tab:\nYou need to transfer a little bit of gas to your oracle so it can fulfill price data requests:\nAnd finally, you will need to authorize the oracle address in your smart contract:\nNow you can call the \"requestPrice\" function of the contract, and assuming you followed all the previous steps,\nthe oracle should send you a response:\nYou should be able to see the retrieved token price now:\nIn this article we demonstrated a simple price feed oracle, however the possibilities of the Kenshi Oracle Network\nare limitless! Be sure to follow us on Twitter if you want more news about Kenshi or more awesome articles about\nthe Kenshi Oracle Network.\nYou can view the source code of this sample oracle\nhere on GitHub.",
    "breadcrumb": [
      {
        "url": "/blog",
        "title": "Blog"
      },
      {
        "url": "/blog/how-to-make-a-coingecko-price-oracle-using-the-kenshi-oracle-network",
        "title": "How to make a CoinGecko price oracle using the Kenshi Oracle Network"
      }
    ]
  },
  {
    "text": "If your business has anything to do with the internet or if you use the internet\nfor marketing your products and services, you need to know how to make your\nbusiness web3 ready. Want to know why?\nBecause ever since we got access to the world wide web, businesses have been\ntrying to leverage it for their benefit. The internet has changed business\nmodels, marketing, and sales practices. It's also been transforming itself, and\nthe latest significant change that's been gradually happening over the past few\nyears is a transition between web2 and web3.\nThe recent history of the markets shows us that when businesses can't bend with\nthe winds of change, they break. So if you don't want your business to fail or\nif you're going to build a new business for these recent times, read on.\nAt first, we had Web 1.0, a read-only collection of static web pages. Then came\nWeb 2.0, the current iteration of the web, and it made a read-write model\npossible. With this model, a new problem emerged.\nBig companies made open platforms and offered free services that attracted\nmillions of users. However, these users soon realized they were trading their\npersonal data in exchange for these free services.\nWe're going forward with a new vision to improve things, towards web 3.0 or\nWeb3. People will own their data in a new read-write-own model in this new era.\nWe are currently on a path that will take us from Web 2.0 to Web3. And as we use\nblockchains and other decentralized systems, like DAOs, and innovations like\ncryptocurrencies and NFTs more and more, we go further down this path.\nAs a business owner or a decision maker, you need to know where this path will\nlead and how you can make your business Web3 ready to make the most of the\njourney. Here are seven actionable tips to get you started:\nImagine wanting to immigrate to a new country with a different language and a\nwhole new set of customs. You would start learning about that country months or\neven years before making your final move.\nWeb3 and blockchain technology are similar. They may be complete unknowns to\nyou, and they have their language and rules. So to be ready for Web3, you must\nstart learning now.\nReturning to our earlier analogy, what if you had a knowledgeable guide who had\nexperience living in your country of destination? What if they could talk you\nthrough their experiences, make suggestions, or even take a short trip to get to\nknow that country? You would be glad to have this kind of guide.\nWhy do the same for your Web3 journey? Do your research first. Then, find a\ngreat team of Web3 and blockchain experts to guide you.\nOne of the easiest ways to dip your toes in these new waters is to start\nexperimenting with cryptocurrencies or NFTs. This experiment can be as simple as\naccepting Bitcoin, Ether, or other cryptocurrencies as payment. Several\ncompanies offer crypto payment gateways for every kind of online business.\nYou can also design and mint NFTs for your company and attach a specific benefit\nfor their holders. Many big brands are already experimenting with\ncryptocurrencies and NFTs. You can join them!\nPossibilities are many in this realm, restricted only by your imagination and\nthe crypto regulations of your country. So beware and get advice from an expert\nbefore you get yourself in trouble.\nHave you ever heard of the Metaverse? It puts forward a unique vision for Web3\nthat everybody may not adopt. However, VR (virtual reality) is here to stay,\neven if the Metaverse gets scrapped.\nYou can get creative and create VR content, buy some virtual property and open a\nnew storefront in a virtual land, build your version of the Metaverse, or try\nadvertising in a blockchain game or dApp that uses virtual reality.\nRemember that to enter the world of VR, your audience will need VR headsets.\nThese headsets are costly, and many people must familiarize themselves with\nthem. So the barrier to entry for many people needs to be lowered.\nThis barrier is why you should consider AR (augmented reality). People will only\nneed their smartphones to consume your AR content, and using it can seriously\nbolster your digital marketing efforts.\nWeb3 is all about decentralization and complete autonomy. If your company uses\nrestrictive hierarchies of power or has a centralized and traditional structure,\nyou should initiate changes in the corporate culture.\nWe're not saying that every business should become a DAO (decentralized\nautonomous organization). But you'll need an environment that fosters change and\ninnovation if you want to thrive, not just survive, in the Web3 era.\nDepending on your business type and the type of products or services you offer,\nyou can create wholly new and Web3-specific offerings. Start brainstorming with\nyour team, and going back to tip no.1, get help from experts.\nAfter finding an idea that makes sense for your business, build an MVP (minimum\nviable product) and test everything. You'll learn valuable lessons even if you\ndo not ship this new product.\nBlockchain is not just a ledger; there isn't just one blockchain. This\ntechnology can have many use cases. You can build on a blockchain or develop\nyour blockchain from scratch. You can use other tools that work with a\nblockchain as well.\nBut first, you should understand that only some things must be on a blockchain.\nSo get to know the space and assess the needs of your business honestly. You may\nwant a complete overhaul to stay viable in the future, or you may wish to become\nmore compatible with Web3 and its tool.\nWeb3 has yet to arrive. Competing visions want to become the next iteration of\nthe worldwide web. Only time will tell that which concept will win. Blockchain\ntechnology is still relatively new, and it needs time to mature.\nYou should be ready for anything and carefully follow innovations and\ndevelopments in this space. A few years ago, we didn't have cryptocurrencies,\nNFTs, smart contracts, dApps, blockchain games, the Metaverse, etc. Who knows\nwhat we'll have in a couple of years? The next big thing will be just right for\nyour business.\nThere are many benefits to working with blockchains, cryptocurrencies, NFTs, and\nmore. But there are risks too. Tread with care when it comes to making your\nbusiness Web3-ready.\nIf you need help or want some consultation on how to move forward, contact\nKenshi today! Our team of experienced developers has the expertise you need for\nthe future of your business in Web3.",
    "breadcrumb": [
      {
        "url": "/blog",
        "title": "Blog"
      },
      {
        "url": "/blog/how-to-make-your-business-web3-ready-seven-actionable-tips",
        "title": "How to Make Your Business Web3 Ready: 7 Actionable Tips"
      }
    ]
  },
  {
    "text": "Kenshi is a full-stack application development platform targeting the blockchain.\nKenshi enables fast product development and reduces time to market. Whether you\nwant to index and query blockchain data or deliver data to the blockchain,\nKenshi has you covered and enables two-way communication.\nOur vision is to lift the limitations faced by developers each day and allow\nthem to build more innovative blockchain applications with real-world use cases.\nWhether you are making complex applications or smart contracts interacting with\nmachines and IoT devices outside the blockchain, we'd love to help you bring\nyour ideas to life.\nKenshi provides the following services:\nDeep Index: Allows indexing blockchain events for blazing-fast access.\nIoT SDK: Allows receiving blockchain events on IoT devices.\nOracle Network: Allows creating custom oracles.",
    "breadcrumb": [
      {
        "url": "/blog",
        "title": "Blog"
      },
      {
        "url": "/blog/kenshi",
        "title": "What is Kenshi?"
      }
    ]
  },
  {
    "text": "The Kenshi Oracle Network is a complete platform for building custom oracles. It takes care\nof the boring and time consuming stuff like event sourcing, task queues, security, caching,\nscaling, nonce management, error management, data delivery, and retries so you can focus on\nyour business logic. With the\nKenshi Oracle Network,\nyou develop your oracle's logic using the technology of your choice, and we take care\nof the rest for you.\nYour only limitation is your imagination! Whether you want to check if your user owns a specific\nNFT on another chain, want to check the price of a token or a real-life asset, or check the weather\ndata or the results of a sports match, all is possible on the Kenshi Oracle Network.\nYou can find a few blueprints for custom oracles in our\ndocumentation:\nSimple Oracle  shows you how to implement the simplest possible oracle. You can start\nfrom this blueprint and build something magical.\nPrice Oracle  shows you how to implement a price oracle, sourcing the price data\nfrom CoinGecko.\nWeather Oracle  is a sample weather oracle using the BrightSky APIs.\nProof of Balance Oracle!  Do you want to check if a user owns a specific asset on another chain?\nThis oracle shows you how to do that.\nVRF Oracle  blueprint uses the Kenshi ECVRF libraries to create a standards-compliant\ndedicated VRF oracle.\nYou need to implement Kenshi's Custom Oracle Protocol using your preferred technologies\nand host them on a serverless (or serverful!) platform such as Vercel, Cloudflare Workers,\nor AWS Lambda. You can use Python, Go, Node.js, or any other programming language.\nThe Custom Oracle Protocol is simple; you need a public HTTP[object Object] endpoint that receives\nevents from the Oracle Network's Event Dispatcher, processes the event, and returns a JSON\nresponse with instructions on what to do with the event. You can read more about it in our\ndocumentation.\nYou also need a smart contract to make this work. You need to emit an event from your contract;\nwe send this event to your custom oracle for processing. The Oracle Network then needs to call\na method on your smart contract to deliver the results.\nOnce these are ready, go to the Kenshi Oracle Network dashboard\nand click on the create button.\nThen you input your contract's address and ABI, configure a few parameters, and you're good to go.\nKenshi provides the following services:\nI'm glad you asked! We have already prepared a page about security in our\ndocumentation. Let's go\nthrough a few of the critical points!\nWe derive the private key of each oracle from an HDWallet stored in a secure secret manager.\nPrivate keys and seed phrases are not stored or accessible elsewhere.\nWe recommend you supply the oracle with enough gas for only a few requests. When there's a new\nrequest, Kenshi sends it to your oracle's endpoint for processing; you can check the balance\nof the oracle there and add gas if required.\nWe recommend signing your data and verifying it on-chain as instructed in “EIP-712: Typed\nstructured data hashing and signing.” This way, you can ensure no validator or attacker\nhas manipulated your data in the delivery process.\nUltimately, the oracle will be as safe as you, the developer, can make it. You will be safe if you\nfollow the security recommendations in our\ndocumentation.\nVery little. We charge a fixed $49.95 per month plus $0.0002 per request. We will adjust\nthe price as we learn more about the oracle needs of our clients!\nYou can head over to our dashboard and create a\ncustom oracle. Check the documentation and\nblueprints to get started quickly.\nHappy hacking on the Oracle Network!",
    "breadcrumb": [
      {
        "url": "/blog",
        "title": "Blog"
      },
      {
        "url": "/blog/introducing-the-kenshi-oracle-network",
        "title": "Introducing the Kenshi Oracle Network"
      }
    ]
  },
  {
    "text": "Blockchain technology is created to address a few main problems: privacy and\ndata security. Due to this focus, blockchains are designed to be run on\nclosed-off networks that can't natively communicate with legacy systems and web2\nAPIs. What can you do when you want to use off-chain, real-world data in your\ndApps? The short answer is that you need to use blockchain oracles. For the long\nexplanation, read on.\nMost blockchains are secured and validated by a peer-to-peer (P2P) network of\ncomputers. These validators work together to reach a consensus and determine the\ncurrent state of the blockchain.\nEach blockchain has a different mechanism for reaching consensus. Whatever the\nmechanism, all nodes need the same access to the same data, and most of them\nmust reach the same conclusion for the state of the blockchain to change and for\nthe transactions to happen.\nIn other words, blockchains are deterministic networks, meaning that every\ntransaction must produce the same result, no matter which validator tries to\nprocess it and when. This is why they are closed off by design.\nImagine that I want to send you some money in the form of cryptocurrency. For\nthis to happen, all validators must check my wallet to see if I have enough to\ncover the amount I want to send + the transaction fee.\nIf I have enough, the gas fee will go to one of the validators, and the\ntransaction will happen. Now, the nodes will subtract the transaction amount\nfrom my wallet and add it to yours. The state of the blockchain will also change\nto reflect these new changes.\nWhat if I wanted to write a smart contract to let people exchange one\ncryptocurrency for another? This contract would need access to the real-time\nexchange rates of these cryptocurrencies. As we all know, these exchange rates\ncan vary from one second to another, unlike the balance in my wallet.\nIn this scenario, if I use a regular web2 API, it could give a different answer\neach time a blockchain node asks it for the exchange rate to validate a\ntransaction. This uncertainty would make reaching a consensus impossible, which\nis precisely why we need blockchain oracles.\nAn oracle is a device or entity that brings off-chain data to a blockchain. How\ndo oracles avoid the problem we mentioned above?\nFirst, they call the API and get the data. Then, they report the result in a\ntransaction. This way, your smart contract will have the data it needs, and the\nnodes will have everything they need to reach a consensus.\nIn our trading smart contract example, we can use a trusted source as an oracle\nto get the real-time exchange rates onto the blockchain. This oracle will report\nthe exchange rate for any transaction that wants to occur in another prior\ntransaction.\nBecause blockchains are immutable, once a transaction occurs, no one can change\nits data without simultaneously attacking most validators. When the price is\nreported in a transaction, it is there for everyone to see, and no one can\nchange it.\nThis is how our first problem is solved.\nWe need help with off-chain data and blockchains. That's when oracles become a\nsingle point of failure and hurt the decentralized nature of the blockchains.\nBlockchains are designed as trustless and decentralized systems. When you want\nto bridge the gap between web3 and web2, you introduce the old problems to the\nnew system.\nWhen it comes to using oracles, you need to be careful. Either use a source\nyou've tested and trust completely or get help from a team of blockchain\ndevelopment experts.\n(If you have a web2 online business and want to bring it to web3, read our guide\nfor making your business web3 ready or contact us to be your guide!)\nSoftware Oracles:  If the data you want to bring to the blockchain exists online\nand in a digital format, you'll use a software oracle. Software oracles utilize\nweb2 APIs and databases as their source. Oracles that deliver exchange rates are\nan example of this.\nHardware Oracles:  There aren't many hardware oracles right now. As IoT (Internet\nof Things) grows, there'll be more use cases for this type of oracle. Hardware\noracles get their data from the real world via hardware like a sensor.\nHuman Oracles:  Using a human oracle, you can have an expert's input for your dApp\nor smart contract. Human oracles can gather the information you need or manually\ncheck the accuracy of data and deliver the results to the blockchain.\nInbound Oracles:  Any oracle that brings off-chain data to a blockchain is inbound.\nAll of the above examples were of this kind.\nOutbound Oracles:  Outbound oracles are rare right now. They do the opposite of a\nregular oracle and deliver on-chain data from the blockchain to the outside\nworld. For example, an outbound oracle may provide some data about liquidity or\nthe aggregate amount of transactions from a smart contract to a website.\nFun fact: the word oracle was used in ancient times to refer someone who could\nprovide valuable or divine insights. The concept of human oracles in web3 is\nclose to the original meaning.\nAs with any other new technology, it mostly depends on your creativity. We've\nseen the use of blockchain oracles in games, betting systems, NFTs, DeFi, and\neven insurance-related products.\nIf you want to build an online business on web3, you'll need to use some\nblockchain oracle at some point. If you have a web2 company that offers any\nAPIs, you can bring them to web3 using an oracle network like Kenshi's.\nBringing your online business to web3 can seem like a daunting task. A lot of\nstuff is different when you build on a blockchain. Not everything has to be,\nthough. That's why we've built Kenshi's Oracle Network as a platform.\nKenshi has a high-performance oracle network that can host your custom oracles.\nYou can use the technology you're already familiar with, even on web3. This\nnetwork uses the same asynchronous, serverless technology as the Kenshi Deep\nIndex to bring you these features and more:\nEvent sourcing:  you can source any event on a blockchain and send it\nto your oracle to be processed.\nCaching:  so that no requests get processed twice.\nGas station:  to calculate gas fees with \"fast\" transactions.\nDelivery:  10 retries if something goes wrong with your initial request.\nNonce management:  keeping your transactions in order and ensuring that\nnonces are not skipped.\nYou can do all this using your preferred technology and the tools you already\nemploy. It would help if you implemented Kenshi's Custom Oracle Protocol.\nTo learn more about custom oracles on Kenshi's Oracle Network, read our\ndocumentation here or start with one of our\noracle blueprints or sample codes.\nWe need randomness in many dApps and smart contracts. Because of the\ndeterministic nature of the blockchain, you can't use an on-chain solution to\ncreate it. If you want genuine unpredictability in your games, NFTs, betting\nsystems, and more, you must use a VRF oracle.\nFortunately, Kenshi's got you covered here too. Our VRF oracle can generate\nrandom numbers and deliver them to your app or contract, complete with\nverifiable proof that shows it hasn't been tampered with. You can learn more\nabout Kenshi's VRF oracle\nhere.\nTo start with Kenshi's Custom Oracle Network, connect your wallet to the\ndashboard. If your business offers a web2 API,\ncontact us to bring it to web3 quickly.\nA whole new market is waiting for you!",
    "breadcrumb": [
      {
        "url": "/blog",
        "title": "Blog"
      },
      {
        "url": "/blog/what-are-blockchain-oracles-and-why-do-you-need-them",
        "title": "What Are Blockchain Oracles and Why Do You Need Them?"
      }
    ]
  },
  {
    "text": "Since the creation of the internet, developers have relied on different tools to build their\napplications and websites. Over time, these tools have become more sophisticated and easier to use\nand now that we enter the age of Web3, we have an entirely new set of blockchain development tools.\nSo whether you're a seasoned developer looking to dip your toes in this relatively new territory\nor just someone interested in becoming a Web3 and blockchain developer, you need to be familiar\nwith these tools to start building on the blockchain. That's why we made this handy list just for you!\nFirst things first, you'll need to use some programming language to build your apps as a developer.\nThough technically not tools themselves, programming languages will significantly impact which blockchain\ndevelopment tools you can and should use down the line. So choose carefully.\nThese are the best languages to learn for developing on a blockchain:\nSolidity is the programming language most associated\nwith the Ethereum blockchain. However, it also works with other EVM blockchains (Ethereum Virtual Machine).\nYou will use Solidity to create smart contracts and dApps. Smart contracts can facilitate lending,\nborrowing, trading, escrow, voting, and many other things. There are many potential use cases, and you\ncan test them out if you learn how to code in Solidity.\nYou can learn more about this programming language by reading its documentation.\ndApps (or DApps) are decentralized applications that run on the blockchain and usually rely\non smart contracts and cryptocurrencies.\nJavaScript (JS) is a great first language to learn. So you can start here and then move on to Solidity.\nBecause C++, JavaScript, and Python influence Solidity, you'll have an easier time learning it if you\nknow any of these programming languages beforehand.\nMost of the websites you use daily have some JavaScript code; this means you can also use your knowledge\nof this language in front-end development for Web2.\nPython is another good choice for starting your journey to becoming a blockchain developer. Like\nJavaScript, knowing it will help you when you start with Solidity, and it can be used on other\nwebsites, especially by backend programmers.\nYou can use Python and JavaScript to interact with smart contracts using Web3 libraries, which\nis why knowing them will help you as a blockchain and Web3 developer.\nFor a blockchain developer, knowing Solidity is a must. But proficiency in at least\none other programming language like Python or JavaScript will make things easier for you.\nMany applications use the same type of layers and modules to perform the same standard functions,\nand a long time ago, programmers figured out that they could save a lot of time if they had reusable\ncode for these functions. So they started building libraries.\nThere was also the problem of structure. Not everyone knew the best practices for writing clean code,\nand this is where frameworks came in to solve the problem. Programming frameworks give you a ready-made,\nstandardized structure for your application.\nWith frameworks and libraries, you don't have to reinvent the wheel for every one of your projects.\nBut even after using them and writing your app, you'll need another environment to test it before the\nfinal deployment. If you're a blockchain developer, this environment would be called a test blockchain\nor test node.\nLet's see some of the best options when it comes to these blockchain development tools:\nHardhat will give you an ideal environment to develop smart contracts\nand dApps. It comes with the Hardhat network, which allows you to build on a local Ethereum node on\nyour local machine. In other words, it is a test blockchain on which you can deploy your smart\ncontracts, then test and debug them.\nYou'll be able to use Solidity and JavaScript on Hardhat.\nBlockchain is forever! Once you deploy your smart contract on an actual blockchain,\nyou won't be able to edit or change it. You need to test and debug on a test node first.\nLike Hardhat, Truffle will provide you with an environment to build,\ntest, debug, and deploy your smart contracts. Truffle uses a test blockchain called Ganache, which\nwill give you access to a local Ethereum node.\nTruffle supports Solidity and JavaScript as well. Hardhat and Truffle are similar. The final\nchoice between them comes down to your personal preferences.\nBrownie is another framework for developing\nsmart contracts. It also lets you build for Ethereum\nand other EVM blockchains. And it uses Ganache to run a local blockchain for testing purposes.\nBut the main difference between this framework and the previous ones on our list is that Brownie\nis Python-based. So you can use Solidity and Python on it.\nBlockchains are designed as closed systems with limited connections to the outside world. But what\nif your dApps or smart contracts need real-world data to perform a specific task? How can you get\nexternal data into a blockchain? The answer is through the use of an oracle.\nOracles are like bridges that connect your dApp or smart contract to a trusted source of information.\nFor example, you'll need access to real-time cryptocurrency prices and exchange rates to build a\ntrading app. And the only way to get this data to your dApp is an oracle.\nIf you want to get data from online sources, you need to use an oracle. But you can also use hardware\noracles to receive data from information-reading gadgets and IoT devices (Internet of Things).\nIf you want to use oracles, you need to be familiar with these tools:\nKenshi has built a high-performance asynchronous oracle network for hosting custom oracles. This\nnetwork will let you develop your oracles using the tools and technology you already know.\n(Read the documentation here.)\nYou can also use our blueprints\nas a guide to get started with a price oracle, weather oracle, proof of balance oracle, and more.\nKenshi also offers all the tools you need to build a VRF (verifiable random function) oracle\nfor your dApp or smart contract. You need randomness in games, lotteries, betting systems,\nand more. VRF oracles can provide this randomness safely and securely.\nChainlink offers access to a network of oracles you can use for your apps and smart contracts.\nYou can utilize one source or multiple sources for the data you need, and Chainlink will use\nits process to provide you with the best possible source and answer.\nIf you don't want to slow down your dApp, you need fast oracles. Kenshi's VRF oracle is\nmuch faster than Chainlink's. You can read about our comparison between the two\nhere.\nAfter you build your app, you'll need access to your chosen blockchain to deploy it. Blockchain is a\nclosed, peer-to-peer network of nodes. These nodes work together to keep the whole network secure\nand reliable. When you want to deploy your app or contract, you need to do it through one of them.\nYou can use an already running node through a node provider or create and run one yourself,\nwhich can be costly and technically challenging. Either way, you should be familiar with\nthese blockchain tools:\nInfura started as a node provider (node as a service platform)\nfor the Ethereum blockchain. But now, it provides access to many layer1 and layer2 blockchains\nand also includes other services for developers.\nAlchemy and QuickNode are\nnode providers that can give you access to Web3 development tools.\nInfura, Alchemy, and QuickNode have similar features when providing access to blockchains.\nSo the final choice between them comes down to your personal preferences and other features\nyou look for in a node provider.\nChainstack is another platform that can give you quick and easy\naccess to a blockchain node. It supports Ethereum and many other layer1 and layer2 blockchain protocols.\nChainstack also provides Web3 development tools and solutions for your projects,\nsuch as multi-cloud, hybrid, and on-premises hosting and globally distributed deployments.\nChainstack is our official partner, and we can tell you first-hand about their fast and reliable\nservice. Read more about this partnership here.\nIf you want to help strengthen a decentralized blockchain while being able to deploy your apps\nand contracts, you can set up and operate a node yourself. To get started with the Ethereum\nblockchain, you should check out the official Go implementation of the Ethereum protocol or\n\"Geth.\"\nBlockchains are like massive databases with no native searchability. So finding the information\nyou want on them can take time and effort. That's why you'll need a tool to explore the blockchain,\ncollect the data you wish to, and index it, so you can use simple queries to get the intended\nfinal results for your app or contract.\nKenshi offers three services with its deep index tool. You can use \"sync\" to retrieve, store,\nand index data. Then you can query and search the indexed data using MQL or GraphQL to get the\nfinal results for your app. Finally, you can get notifications about new blockchain events\non your HTTP endpoints, which you can do through Reverse-API.\nYou can learn more about these services by reading the\ndocumentation.\nYou've seen the option to sign-up and log in with google, or some other service, on different\nwebsites. That's Web2. But there is something similar in Web3. On the blockchain, you'll have\none identity: your public address created by your wallet.\nSo to use any service that interacts with Web3, you will need a wallet. There are many options.\nBut to make things easier, you should choose a wallet built primarily to interact with Web3\napps and contracts.\nMetaMask is the wallet of choice for many developers and crypto\nholders for a good reason. It is designed for one main application: to connect you to Web3,\npowered by Ethereum and other EVM blockchains.\nThe easiest way to use MetaMask is to install it on your browser as an extension. But remember\nthat with these kinds of \"hot\" wallets, you should be extra careful. Otherwise, you can fall\nvictim to a scam and lose everything in your wallet.\nBrave is a browser compatible with Web3 out of the box. It has a\nbuilt-in wallet that works similarly to MetaMask. You should try this browser; using the\nbrave wallet will be a natural and easy choice.\nWhen it comes to cryptocurrencies like Ethereum, we have several units of measurement.\nA small mistake in converting one to the other when writing a dApp or smart contract can have\ncatastrophic consequences. So bookmark this handy tool\nand thank us later.\nEtherscan is a blockchain explorer that can give you a lot of\ninformation about the current state of Ethereum, transactions on this blockchain, and more.\nYou'll need many tools to start your journey as a newbie blockchain developer. We introduced\nsome of the essential blockchain development tools here. But there are many more. Send this\narticle to your fellow programmers and ask them for their recommendations. It's the only way\nthat the Web3 community will grow: by collaborating.\nGo to the Kenshi dashboard and connect your wallet to get started with\nKenshi's tools. Start building with Kenshi today!",
    "breadcrumb": [
      {
        "url": "/blog",
        "title": "Blog"
      },
      {
        "url": "/blog/top-blockchain-development-tools-for-success-on-web3",
        "title": "Top 18 Blockchain Development Tools for Success on Web3"
      }
    ]
  },
  {
    "text": "Kenshi is a Swiss-based blockchain company offering services such as\nCustom Oracle Network,\nblockchain IoT SDK,\nDeep Indexing,\nGraphQL, and\nReverse-API (webhooks)\non Ethereum, Aurora, Avalanche, Fantom, Polygon and the BNB Smart Chain.\nBuying the token? Make sure you read the token documentation first.",
    "breadcrumb": [
      {
        "url": "/blog",
        "title": "Blog"
      }
    ]
  }
]